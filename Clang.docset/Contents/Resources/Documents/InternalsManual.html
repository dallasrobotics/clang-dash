<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>“Clang” CFE Internals Manual &mdash; Clang 3.7 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Clang 3.7 documentation" href="index.html" />
    <link rel="next" title="Driver Design &amp; Internals" href="DriverInternals.html" />
    <link rel="prev" title="Clang-Format Style Options" href="ClangFormatStyleOptions.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 3.7 documentation</span></a></h1>
        <h2 class="heading"><span>“Clang” CFE Internals Manual</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ClangFormatStyleOptions.html">Clang-Format Style Options</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="DriverInternals.html">Driver Design &amp; Internals</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="clang-cfe-internals-manual">
<h1>&#8220;Clang&#8221; CFE Internals Manual<a class="headerlink" href="#clang-cfe-internals-manual" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id3">Introduction</a></li>
<li><a class="reference internal" href="#llvm-support-library" id="id4">LLVM Support Library</a></li>
<li><a class="reference internal" href="#the-clang-basic-library" id="id5">The Clang &#8220;Basic&#8221; Library</a><ul>
<li><a class="reference internal" href="#the-diagnostics-subsystem" id="id6">The Diagnostics Subsystem</a><ul>
<li><a class="reference internal" href="#the-diagnostic-kinds-td-files" id="id7">The <code class="docutils literal"><span class="pre">Diagnostic*Kinds.td</span></code> files</a></li>
<li><a class="reference internal" href="#the-format-string" id="id8">The Format String</a></li>
<li><a class="reference internal" href="#formatting-a-diagnostic-argument" id="id9">Formatting a Diagnostic Argument</a></li>
<li><a class="reference internal" href="#producing-the-diagnostic" id="id10">Producing the Diagnostic</a></li>
<li><a class="reference internal" href="#fix-it-hints" id="id11">Fix-It Hints</a></li>
<li><a class="reference internal" href="#the-diagnosticclient-interface" id="id12">The <code class="docutils literal"><span class="pre">DiagnosticClient</span></code> Interface</a></li>
<li><a class="reference internal" href="#adding-translations-to-clang" id="id13">Adding Translations to Clang</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-sourcelocation-and-sourcemanager-classes" id="id14">The <code class="docutils literal"><span class="pre">SourceLocation</span></code> and <code class="docutils literal"><span class="pre">SourceManager</span></code> classes</a></li>
<li><a class="reference internal" href="#sourcerange-and-charsourcerange" id="id15"><code class="docutils literal"><span class="pre">SourceRange</span></code> and <code class="docutils literal"><span class="pre">CharSourceRange</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-driver-library" id="id16">The Driver Library</a></li>
<li><a class="reference internal" href="#precompiled-headers" id="id17">Precompiled Headers</a></li>
<li><a class="reference internal" href="#the-frontend-library" id="id18">The Frontend Library</a></li>
<li><a class="reference internal" href="#the-lexer-and-preprocessor-library" id="id19">The Lexer and Preprocessor Library</a><ul>
<li><a class="reference internal" href="#the-token-class" id="id20">The Token class</a></li>
<li><a class="reference internal" href="#annotation-tokens" id="id21">Annotation Tokens</a></li>
<li><a class="reference internal" href="#the-lexer-class" id="id22">The <code class="docutils literal"><span class="pre">Lexer</span></code> class</a></li>
<li><a class="reference internal" href="#the-tokenlexer-class" id="id23">The <code class="docutils literal"><span class="pre">TokenLexer</span></code> class</a></li>
<li><a class="reference internal" href="#the-multipleincludeopt-class" id="id24">The <code class="docutils literal"><span class="pre">MultipleIncludeOpt</span></code> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-parser-library" id="id25">The Parser Library</a></li>
<li><a class="reference internal" href="#the-ast-library" id="id26">The AST Library</a><ul>
<li><a class="reference internal" href="#the-type-class-and-its-subclasses" id="id27">The <code class="docutils literal"><span class="pre">Type</span></code> class and its subclasses</a><ul>
<li><a class="reference internal" href="#canonical-types" id="id28">Canonical Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-qualtype-class" id="id29">The <code class="docutils literal"><span class="pre">QualType</span></code> class</a></li>
<li><a class="reference internal" href="#declaration-names" id="id30">Declaration names</a></li>
<li><a class="reference internal" href="#declaration-contexts" id="id31">Declaration contexts</a><ul>
<li><a class="reference internal" href="#redeclarations-and-overloads" id="id32">Redeclarations and Overloads</a></li>
<li><a class="reference internal" href="#lexical-and-semantic-contexts" id="id33">Lexical and Semantic Contexts</a></li>
<li><a class="reference internal" href="#transparent-declaration-contexts" id="id34">Transparent Declaration Contexts</a></li>
<li><a class="reference internal" href="#multiply-defined-declaration-contexts" id="id35">Multiply-Defined Declaration Contexts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-cfg-class" id="id36">The <code class="docutils literal"><span class="pre">CFG</span></code> class</a><ul>
<li><a class="reference internal" href="#basic-blocks" id="id37">Basic Blocks</a></li>
<li><a class="reference internal" href="#entry-and-exit-blocks" id="id38">Entry and Exit Blocks</a></li>
<li><a class="reference internal" href="#conditional-control-flow" id="id39">Conditional Control-Flow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#constant-folding-in-the-clang-ast" id="id40">Constant Folding in the Clang AST</a><ul>
<li><a class="reference internal" href="#implementation-approach" id="id41">Implementation Approach</a></li>
<li><a class="reference internal" href="#extensions" id="id42">Extensions</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-sema-library" id="id43">The Sema Library</a></li>
<li><a class="reference internal" href="#the-codegen-library" id="id44">The CodeGen Library</a></li>
<li><a class="reference internal" href="#how-to-change-clang" id="id45">How to change Clang</a><ul>
<li><a class="reference internal" href="#how-to-add-an-attribute" id="id46">How to add an attribute</a><ul>
<li><a class="reference internal" href="#attribute-basics" id="id47">Attribute Basics</a></li>
<li><a class="reference internal" href="#include-clang-basic-attr-td" id="id48"><code class="docutils literal"><span class="pre">include/clang/Basic/Attr.td</span></code></a><ul>
<li><a class="reference internal" href="#spellings" id="id49">Spellings</a></li>
<li><a class="reference internal" href="#subjects" id="id50">Subjects</a></li>
<li><a class="reference internal" href="#documentation" id="id51">Documentation</a></li>
<li><a class="reference internal" href="#arguments" id="id52">Arguments</a></li>
<li><a class="reference internal" href="#other-properties" id="id53">Other Properties</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boilerplate" id="id54">Boilerplate</a></li>
<li><a class="reference internal" href="#semantic-handling" id="id55">Semantic handling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-add-an-expression-or-statement" id="id56">How to add an expression or statement</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id3">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes some of the more important APIs and internal design
decisions made in the Clang C front-end.  The purpose of this document is to
both capture some of this high level information and also describe some of the
design decisions behind it.  This is meant for people interested in hacking on
Clang, not for end-users.  The description below is categorized by libraries,
and does not describe any of the clients of the libraries.</p>
</div>
<div class="section" id="llvm-support-library">
<h2><a class="toc-backref" href="#id4">LLVM Support Library</a><a class="headerlink" href="#llvm-support-library" title="Permalink to this headline">¶</a></h2>
<p>The LLVM <code class="docutils literal"><span class="pre">libSupport</span></code> library provides many underlying libraries and
<a class="reference external" href="http://llvm.org/docs/ProgrammersManual.html">data-structures</a>, including
command line option processing, various containers and a system abstraction
layer, which is used for file system access.</p>
</div>
<div class="section" id="the-clang-basic-library">
<h2><a class="toc-backref" href="#id5">The Clang &#8220;Basic&#8221; Library</a><a class="headerlink" href="#the-clang-basic-library" title="Permalink to this headline">¶</a></h2>
<p>This library certainly needs a better name.  The &#8220;basic&#8221; library contains a
number of low-level utilities for tracking and manipulating source buffers,
locations within the source buffers, diagnostics, tokens, target abstraction,
and information about the subset of the language being compiled for.</p>
<p>Part of this infrastructure is specific to C (such as the <code class="docutils literal"><span class="pre">TargetInfo</span></code>
class), other parts could be reused for other non-C-based languages
(<code class="docutils literal"><span class="pre">SourceLocation</span></code>, <code class="docutils literal"><span class="pre">SourceManager</span></code>, <code class="docutils literal"><span class="pre">Diagnostics</span></code>, <code class="docutils literal"><span class="pre">FileManager</span></code>).
When and if there is future demand we can figure out if it makes sense to
introduce a new library, move the general classes somewhere else, or introduce
some other solution.</p>
<p>We describe the roles of these classes in order of their dependencies.</p>
<div class="section" id="the-diagnostics-subsystem">
<h3><a class="toc-backref" href="#id6">The Diagnostics Subsystem</a><a class="headerlink" href="#the-diagnostics-subsystem" title="Permalink to this headline">¶</a></h3>
<p>The Clang Diagnostics subsystem is an important part of how the compiler
communicates with the human.  Diagnostics are the warnings and errors produced
when the code is incorrect or dubious.  In Clang, each diagnostic produced has
(at the minimum) a unique ID, an English translation associated with it, a
<a class="reference internal" href="#sourcelocation"><span>SourceLocation</span></a> to &#8220;put the caret&#8221;, and a severity
(e.g., <code class="docutils literal"><span class="pre">WARNING</span></code> or <code class="docutils literal"><span class="pre">ERROR</span></code>).  They can also optionally include a number of
arguments to the dianostic (which fill in &#8220;%0&#8220;&#8216;s in the string) as well as a
number of source ranges that related to the diagnostic.</p>
<p>In this section, we&#8217;ll be giving examples produced by the Clang command line
driver, but diagnostics can be <a class="reference internal" href="#diagnosticclient"><span>rendered in many different ways</span></a> depending on how the <code class="docutils literal"><span class="pre">DiagnosticClient</span></code> interface is
implemented.  A representative example of a diagnostic is:</p>
<div class="highlight-c++"><div class="highlight"><pre>t.c:38:15: error: invalid operands to binary expression (&#39;int *&#39; and &#39;_Complex float&#39;)
P = (P-42) + Gamma*4;
    ~~~~~~ ^ ~~~~~~~
</pre></div>
</div>
<p>In this example, you can see the English translation, the severity (error), you
can see the source location (the caret (&#8220;<code class="docutils literal"><span class="pre">^</span></code>&#8221;) and file/line/column info),
the source ranges &#8220;<code class="docutils literal"><span class="pre">~~~~</span></code>&#8221;, arguments to the diagnostic (&#8220;<code class="docutils literal"><span class="pre">int*</span></code>&#8221; and
&#8220;<code class="docutils literal"><span class="pre">_Complex</span> <span class="pre">float</span></code>&#8221;).  You&#8217;ll have to believe me that there is a unique ID
backing the diagnostic :).</p>
<p>Getting all of this to happen has several steps and involves many moving
pieces, this section describes them and talks about best practices when adding
a new diagnostic.</p>
<div class="section" id="the-diagnostic-kinds-td-files">
<h4><a class="toc-backref" href="#id7">The <code class="docutils literal"><span class="pre">Diagnostic*Kinds.td</span></code> files</a><a class="headerlink" href="#the-diagnostic-kinds-td-files" title="Permalink to this headline">¶</a></h4>
<p>Diagnostics are created by adding an entry to one of the
<code class="docutils literal"><span class="pre">clang/Basic/Diagnostic*Kinds.td</span></code> files, depending on what library will be
using it.  From this file, <strong class="program">tblgen</strong> generates the unique ID of the
diagnostic, the severity of the diagnostic and the English translation + format
string.</p>
<p>There is little sanity with the naming of the unique ID&#8217;s right now.  Some
start with <code class="docutils literal"><span class="pre">err_</span></code>, <code class="docutils literal"><span class="pre">warn_</span></code>, <code class="docutils literal"><span class="pre">ext_</span></code> to encode the severity into the name.
Since the enum is referenced in the C++ code that produces the diagnostic, it
is somewhat useful for it to be reasonably short.</p>
<p>The severity of the diagnostic comes from the set {<code class="docutils literal"><span class="pre">NOTE</span></code>, <code class="docutils literal"><span class="pre">REMARK</span></code>,
<code class="docutils literal"><span class="pre">WARNING</span></code>,
<code class="docutils literal"><span class="pre">EXTENSION</span></code>, <code class="docutils literal"><span class="pre">EXTWARN</span></code>, <code class="docutils literal"><span class="pre">ERROR</span></code>}.  The <code class="docutils literal"><span class="pre">ERROR</span></code> severity is used for
diagnostics indicating the program is never acceptable under any circumstances.
When an error is emitted, the AST for the input code may not be fully built.
The <code class="docutils literal"><span class="pre">EXTENSION</span></code> and <code class="docutils literal"><span class="pre">EXTWARN</span></code> severities are used for extensions to the
language that Clang accepts.  This means that Clang fully understands and can
represent them in the AST, but we produce diagnostics to tell the user their
code is non-portable.  The difference is that the former are ignored by
default, and the later warn by default.  The <code class="docutils literal"><span class="pre">WARNING</span></code> severity is used for
constructs that are valid in the currently selected source language but that
are dubious in some way.  The <code class="docutils literal"><span class="pre">REMARK</span></code> severity provides generic information
about the compilation that is not necessarily related to any dubious code.  The
<code class="docutils literal"><span class="pre">NOTE</span></code> level is used to staple more information onto previous diagnostics.</p>
<p>These <em>severities</em> are mapped into a smaller set (the <code class="docutils literal"><span class="pre">Diagnostic::Level</span></code>
enum, {<code class="docutils literal"><span class="pre">Ignored</span></code>, <code class="docutils literal"><span class="pre">Note</span></code>, <code class="docutils literal"><span class="pre">Remark</span></code>, <code class="docutils literal"><span class="pre">Warning</span></code>, <code class="docutils literal"><span class="pre">Error</span></code>, <code class="docutils literal"><span class="pre">Fatal</span></code>}) of
output
<em>levels</em> by the diagnostics subsystem based on various configuration options.
Clang internally supports a fully fine grained mapping mechanism that allows
you to map almost any diagnostic to the output level that you want.  The only
diagnostics that cannot be mapped are <code class="docutils literal"><span class="pre">NOTE</span></code>s, which always follow the
severity of the previously emitted diagnostic and <code class="docutils literal"><span class="pre">ERROR</span></code>s, which can only
be mapped to <code class="docutils literal"><span class="pre">Fatal</span></code> (it is not possible to turn an error into a warning, for
example).</p>
<p>Diagnostic mappings are used in many ways.  For example, if the user specifies
<code class="docutils literal"><span class="pre">-pedantic</span></code>, <code class="docutils literal"><span class="pre">EXTENSION</span></code> maps to <code class="docutils literal"><span class="pre">Warning</span></code>, if they specify
<code class="docutils literal"><span class="pre">-pedantic-errors</span></code>, it turns into <code class="docutils literal"><span class="pre">Error</span></code>.  This is used to implement
options like <code class="docutils literal"><span class="pre">-Wunused_macros</span></code>, <code class="docutils literal"><span class="pre">-Wundef</span></code> etc.</p>
<p>Mapping to <code class="docutils literal"><span class="pre">Fatal</span></code> should only be used for diagnostics that are considered so
severe that error recovery won&#8217;t be able to recover sensibly from them (thus
spewing a ton of bogus errors).  One example of this class of error are failure
to <code class="docutils literal"><span class="pre">#include</span></code> a file.</p>
</div>
<div class="section" id="the-format-string">
<h4><a class="toc-backref" href="#id8">The Format String</a><a class="headerlink" href="#the-format-string" title="Permalink to this headline">¶</a></h4>
<p>The format string for the diagnostic is very simple, but it has some power.  It
takes the form of a string in English with markers that indicate where and how
arguments to the diagnostic are inserted and formatted.  For example, here are
some simple format strings:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;binary integer literals are an extension&quot;</span>
<span class="s">&quot;format string contains &#39;</span><span class="se">\\</span><span class="s">0&#39; within the string body&quot;</span>
<span class="s">&quot;more &#39;%%&#39; conversions than data arguments&quot;</span>
<span class="s">&quot;invalid operands to binary expression (%0 and %1)&quot;</span>
<span class="s">&quot;overloaded &#39;%0&#39; must be a %select{unary|binary|unary or binary}2 operator&quot;</span>
     <span class="s">&quot; (has %1 parameter%s1)&quot;</span>
</pre></div>
</div>
<p>These examples show some important points of format strings.  You can use any
plain ASCII character in the diagnostic string except &#8220;<code class="docutils literal"><span class="pre">%</span></code>&#8221; without a
problem, but these are C strings, so you have to use and be aware of all the C
escape sequences (as in the second example).  If you want to produce a &#8220;<code class="docutils literal"><span class="pre">%</span></code>&#8221;
in the output, use the &#8220;<code class="docutils literal"><span class="pre">%%</span></code>&#8221; escape sequence, like the third diagnostic.
Finally, Clang uses the &#8220;<code class="docutils literal"><span class="pre">%...[digit]</span></code>&#8221; sequences to specify where and how
arguments to the diagnostic are formatted.</p>
<p>Arguments to the diagnostic are numbered according to how they are specified by
the C++ code that <a class="reference internal" href="#internals-producing-diag"><span>produces them</span></a>, and are
referenced by <code class="docutils literal"><span class="pre">%0</span></code> .. <code class="docutils literal"><span class="pre">%9</span></code>.  If you have more than 10 arguments to your
diagnostic, you are doing something wrong :).  Unlike <code class="docutils literal"><span class="pre">printf</span></code>, there is no
requirement that arguments to the diagnostic end up in the output in the same
order as they are specified, you could have a format string with &#8220;<code class="docutils literal"><span class="pre">%1</span> <span class="pre">%0</span></code>&#8221;
that swaps them, for example.  The text in between the percent and digit are
formatting instructions.  If there are no instructions, the argument is just
turned into a string and substituted in.</p>
<p>Here are some &#8220;best practices&#8221; for writing the English format string:</p>
<ul class="simple">
<li>Keep the string short.  It should ideally fit in the 80 column limit of the
<code class="docutils literal"><span class="pre">DiagnosticKinds.td</span></code> file.  This avoids the diagnostic wrapping when
printed, and forces you to think about the important point you are conveying
with the diagnostic.</li>
<li>Take advantage of location information.  The user will be able to see the
line and location of the caret, so you don&#8217;t need to tell them that the
problem is with the 4th argument to the function: just point to it.</li>
<li>Do not capitalize the diagnostic string, and do not end it with a period.</li>
<li>If you need to quote something in the diagnostic string, use single quotes.</li>
</ul>
<p>Diagnostics should never take random English strings as arguments: you
shouldn&#8217;t use &#8220;<code class="docutils literal"><span class="pre">you</span> <span class="pre">have</span> <span class="pre">a</span> <span class="pre">problem</span> <span class="pre">with</span> <span class="pre">%0</span></code>&#8221; and pass in things like &#8220;<code class="docutils literal"><span class="pre">your</span>
<span class="pre">argument</span></code>&#8221; or &#8220;<code class="docutils literal"><span class="pre">your</span> <span class="pre">return</span> <span class="pre">value</span></code>&#8221; as arguments.  Doing this prevents
<a class="reference internal" href="#internals-diag-translation"><span>translating</span></a> the Clang diagnostics to other
languages (because they&#8217;ll get random English words in their otherwise
localized diagnostic).  The exceptions to this are C/C++ language keywords
(e.g., <code class="docutils literal"><span class="pre">auto</span></code>, <code class="docutils literal"><span class="pre">const</span></code>, <code class="docutils literal"><span class="pre">mutable</span></code>, etc) and C/C++ operators (<code class="docutils literal"><span class="pre">/=</span></code>).
Note that things like &#8220;pointer&#8221; and &#8220;reference&#8221; are not keywords.  On the other
hand, you <em>can</em> include anything that comes from the user&#8217;s source code,
including variable names, types, labels, etc.  The &#8220;<code class="docutils literal"><span class="pre">select</span></code>&#8221; format can be
used to achieve this sort of thing in a localizable way, see below.</p>
</div>
<div class="section" id="formatting-a-diagnostic-argument">
<h4><a class="toc-backref" href="#id9">Formatting a Diagnostic Argument</a><a class="headerlink" href="#formatting-a-diagnostic-argument" title="Permalink to this headline">¶</a></h4>
<p>Arguments to diagnostics are fully typed internally, and come from a couple
different classes: integers, types, names, and random strings.  Depending on
the class of the argument, it can be optionally formatted in different ways.
This gives the <code class="docutils literal"><span class="pre">DiagnosticClient</span></code> information about what the argument means
without requiring it to use a specific presentation (consider this MVC for
Clang :).</p>
<p>Here are the different diagnostic argument formats currently supported by
Clang:</p>
<p><strong>&#8220;s&#8221; format</strong></p>
<dl class="docutils">
<dt>Example:</dt>
<dd><code class="docutils literal"><span class="pre">&quot;requires</span> <span class="pre">%1</span> <span class="pre">parameter%s1&quot;</span></code></dd>
<dt>Class:</dt>
<dd>Integers</dd>
<dt>Description:</dt>
<dd>This is a simple formatter for integers that is useful when producing English
diagnostics.  When the integer is 1, it prints as nothing.  When the integer
is not 1, it prints as &#8220;<code class="docutils literal"><span class="pre">s</span></code>&#8221;.  This allows some simple grammatical forms to
be to be handled correctly, and eliminates the need to use gross things like
<code class="docutils literal"><span class="pre">&quot;requires</span> <span class="pre">%1</span> <span class="pre">parameter(s)&quot;</span></code>.</dd>
</dl>
<p><strong>&#8220;select&#8221; format</strong></p>
<dl class="docutils">
<dt>Example:</dt>
<dd><code class="docutils literal"><span class="pre">&quot;must</span> <span class="pre">be</span> <span class="pre">a</span> <span class="pre">%select{unary|binary|unary</span> <span class="pre">or</span> <span class="pre">binary}2</span> <span class="pre">operator&quot;</span></code></dd>
<dt>Class:</dt>
<dd>Integers</dd>
<dt>Description:</dt>
<dd>This format specifier is used to merge multiple related diagnostics together
into one common one, without requiring the difference to be specified as an
English string argument.  Instead of specifying the string, the diagnostic
gets an integer argument and the format string selects the numbered option.
In this case, the &#8220;<code class="docutils literal"><span class="pre">%2</span></code>&#8221; value must be an integer in the range [0..2].  If
it is 0, it prints &#8220;unary&#8221;, if it is 1 it prints &#8220;binary&#8221; if it is 2, it
prints &#8220;unary or binary&#8221;.  This allows other language translations to
substitute reasonable words (or entire phrases) based on the semantics of the
diagnostic instead of having to do things textually.  The selected string
does undergo formatting.</dd>
</dl>
<p><strong>&#8220;plural&#8221; format</strong></p>
<dl class="docutils">
<dt>Example:</dt>
<dd><code class="docutils literal"><span class="pre">&quot;you</span> <span class="pre">have</span> <span class="pre">%1</span> <span class="pre">%plural{1:mouse|:mice}1</span> <span class="pre">connected</span> <span class="pre">to</span> <span class="pre">your</span> <span class="pre">computer&quot;</span></code></dd>
<dt>Class:</dt>
<dd>Integers</dd>
<dt>Description:</dt>
<dd><p class="first">This is a formatter for complex plural forms.  It is designed to handle even
the requirements of languages with very complex plural forms, as many Baltic
languages have.  The argument consists of a series of expression/form pairs,
separated by &#8221;:&#8221;, where the first form whose expression evaluates to true is
the result of the modifier.</p>
<p>An expression can be empty, in which case it is always true.  See the example
at the top.  Otherwise, it is a series of one or more numeric conditions,
separated by &#8221;,&#8221;.  If any condition matches, the expression matches.  Each
numeric condition can take one of three forms.</p>
<ul class="simple">
<li>number: A simple decimal number matches if the argument is the same as the
number.  Example: <code class="docutils literal"><span class="pre">&quot;%plural{1:mouse|:mice}4&quot;</span></code></li>
<li>range: A range in square brackets matches if the argument is within the
range.  Then range is inclusive on both ends.  Example:
<code class="docutils literal"><span class="pre">&quot;%plural{0:none|1:one|[2,5]:some|:many}2&quot;</span></code></li>
<li>modulo: A modulo operator is followed by a number, and equals sign and
either a number or a range.  The tests are the same as for plain numbers
and ranges, but the argument is taken modulo the number first.  Example:
<code class="docutils literal"><span class="pre">&quot;%plural{%100=0:even</span> <span class="pre">hundred|%100=[1,50]:lower</span> <span class="pre">half|:everything</span> <span class="pre">else}1&quot;</span></code></li>
</ul>
<p class="last">The parser is very unforgiving.  A syntax error, even whitespace, will abort,
as will a failure to match the argument against any expression.</p>
</dd>
</dl>
<p><strong>&#8220;ordinal&#8221; format</strong></p>
<dl class="docutils">
<dt>Example:</dt>
<dd><code class="docutils literal"><span class="pre">&quot;ambiguity</span> <span class="pre">in</span> <span class="pre">%ordinal0</span> <span class="pre">argument&quot;</span></code></dd>
<dt>Class:</dt>
<dd>Integers</dd>
<dt>Description:</dt>
<dd>This is a formatter which represents the argument number as an ordinal: the
value <code class="docutils literal"><span class="pre">1</span></code> becomes <code class="docutils literal"><span class="pre">1st</span></code>, <code class="docutils literal"><span class="pre">3</span></code> becomes <code class="docutils literal"><span class="pre">3rd</span></code>, and so on.  Values less
than <code class="docutils literal"><span class="pre">1</span></code> are not supported.  This formatter is currently hard-coded to use
English ordinals.</dd>
</dl>
<p><strong>&#8220;objcclass&#8221; format</strong></p>
<dl class="docutils">
<dt>Example:</dt>
<dd><code class="docutils literal"><span class="pre">&quot;method</span> <span class="pre">%objcclass0</span> <span class="pre">not</span> <span class="pre">found&quot;</span></code></dd>
<dt>Class:</dt>
<dd><code class="docutils literal"><span class="pre">DeclarationName</span></code></dd>
<dt>Description:</dt>
<dd>This is a simple formatter that indicates the <code class="docutils literal"><span class="pre">DeclarationName</span></code> corresponds
to an Objective-C class method selector.  As such, it prints the selector
with a leading &#8220;<code class="docutils literal"><span class="pre">+</span></code>&#8221;.</dd>
</dl>
<p><strong>&#8220;objcinstance&#8221; format</strong></p>
<dl class="docutils">
<dt>Example:</dt>
<dd><code class="docutils literal"><span class="pre">&quot;method</span> <span class="pre">%objcinstance0</span> <span class="pre">not</span> <span class="pre">found&quot;</span></code></dd>
<dt>Class:</dt>
<dd><code class="docutils literal"><span class="pre">DeclarationName</span></code></dd>
<dt>Description:</dt>
<dd>This is a simple formatter that indicates the <code class="docutils literal"><span class="pre">DeclarationName</span></code> corresponds
to an Objective-C instance method selector.  As such, it prints the selector
with a leading &#8220;<code class="docutils literal"><span class="pre">-</span></code>&#8221;.</dd>
</dl>
<p><strong>&#8220;q&#8221; format</strong></p>
<dl class="docutils">
<dt>Example:</dt>
<dd><code class="docutils literal"><span class="pre">&quot;candidate</span> <span class="pre">found</span> <span class="pre">by</span> <span class="pre">name</span> <span class="pre">lookup</span> <span class="pre">is</span> <span class="pre">%q0&quot;</span></code></dd>
<dt>Class:</dt>
<dd><code class="docutils literal"><span class="pre">NamedDecl</span> <span class="pre">*</span></code></dd>
<dt>Description:</dt>
<dd>This formatter indicates that the fully-qualified name of the declaration
should be printed, e.g., &#8220;<code class="docutils literal"><span class="pre">std::vector</span></code>&#8221; rather than &#8220;<code class="docutils literal"><span class="pre">vector</span></code>&#8221;.</dd>
</dl>
<p><strong>&#8220;diff&#8221; format</strong></p>
<dl class="docutils">
<dt>Example:</dt>
<dd><code class="docutils literal"><span class="pre">&quot;no</span> <span class="pre">known</span> <span class="pre">conversion</span> <span class="pre">%diff{from</span> <span class="pre">$</span> <span class="pre">to</span> <span class="pre">$|from</span> <span class="pre">argument</span> <span class="pre">type</span> <span class="pre">to</span> <span class="pre">parameter</span> <span class="pre">type}1,2&quot;</span></code></dd>
<dt>Class:</dt>
<dd><code class="docutils literal"><span class="pre">QualType</span></code></dd>
<dt>Description:</dt>
<dd>This formatter takes two <code class="docutils literal"><span class="pre">QualType</span></code>s and attempts to print a template
difference between the two.  If tree printing is off, the text inside the
braces before the pipe is printed, with the formatted text replacing the $.
If tree printing is on, the text after the pipe is printed and a type tree is
printed after the diagnostic message.</dd>
</dl>
<p>It is really easy to add format specifiers to the Clang diagnostics system, but
they should be discussed before they are added.  If you are creating a lot of
repetitive diagnostics and/or have an idea for a useful formatter, please bring
it up on the cfe-dev mailing list.</p>
</div>
<div class="section" id="producing-the-diagnostic">
<span id="internals-producing-diag"></span><h4><a class="toc-backref" href="#id10">Producing the Diagnostic</a><a class="headerlink" href="#producing-the-diagnostic" title="Permalink to this headline">¶</a></h4>
<p>Now that you&#8217;ve created the diagnostic in the <code class="docutils literal"><span class="pre">Diagnostic*Kinds.td</span></code> file, you
need to write the code that detects the condition in question and emits the new
diagnostic.  Various components of Clang (e.g., the preprocessor, <code class="docutils literal"><span class="pre">Sema</span></code>,
etc.) provide a helper function named &#8220;<code class="docutils literal"><span class="pre">Diag</span></code>&#8221;.  It creates a diagnostic and
accepts the arguments, ranges, and other information that goes along with it.</p>
<p>For example, the binary expression error comes from code like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">various</span> <span class="n">things</span> <span class="n">that</span> <span class="n">are</span> <span class="n">bad</span><span class="p">)</span>
  <span class="n">Diag</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="n">diag</span><span class="o">::</span><span class="n">err_typecheck_invalid_operands</span><span class="p">)</span>
    <span class="o">&lt;&lt;</span> <span class="n">lex</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">rex</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span>
    <span class="o">&lt;&lt;</span> <span class="n">lex</span><span class="o">-&gt;</span><span class="n">getSourceRange</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">rex</span><span class="o">-&gt;</span><span class="n">getSourceRange</span><span class="p">();</span>
</pre></div>
</div>
<p>This shows that use of the <code class="docutils literal"><span class="pre">Diag</span></code> method: it takes a location (a
<a class="reference internal" href="#sourcelocation"><span>SourceLocation</span></a> object) and a diagnostic enum value
(which matches the name from <code class="docutils literal"><span class="pre">Diagnostic*Kinds.td</span></code>).  If the diagnostic takes
arguments, they are specified with the <code class="docutils literal"><span class="pre">&lt;&lt;</span></code> operator: the first argument
becomes <code class="docutils literal"><span class="pre">%0</span></code>, the second becomes <code class="docutils literal"><span class="pre">%1</span></code>, etc.  The diagnostic interface
allows you to specify arguments of many different types, including <code class="docutils literal"><span class="pre">int</span></code> and
<code class="docutils literal"><span class="pre">unsigned</span></code> for integer arguments, <code class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></code> and <code class="docutils literal"><span class="pre">std::string</span></code> for
string arguments, <code class="docutils literal"><span class="pre">DeclarationName</span></code> and <code class="docutils literal"><span class="pre">const</span> <span class="pre">IdentifierInfo</span> <span class="pre">*</span></code> for names,
<code class="docutils literal"><span class="pre">QualType</span></code> for types, etc.  <code class="docutils literal"><span class="pre">SourceRange</span></code>s are also specified with the
<code class="docutils literal"><span class="pre">&lt;&lt;</span></code> operator, but do not have a specific ordering requirement.</p>
<p>As you can see, adding and producing a diagnostic is pretty straightforward.
The hard part is deciding exactly what you need to say to help the user,
picking a suitable wording, and providing the information needed to format it
correctly.  The good news is that the call site that issues a diagnostic should
be completely independent of how the diagnostic is formatted and in what
language it is rendered.</p>
</div>
<div class="section" id="fix-it-hints">
<h4><a class="toc-backref" href="#id11">Fix-It Hints</a><a class="headerlink" href="#fix-it-hints" title="Permalink to this headline">¶</a></h4>
<p>In some cases, the front end emits diagnostics when it is clear that some small
change to the source code would fix the problem.  For example, a missing
semicolon at the end of a statement or a use of deprecated syntax that is
easily rewritten into a more modern form.  Clang tries very hard to emit the
diagnostic and recover gracefully in these and other cases.</p>
<p>However, for these cases where the fix is obvious, the diagnostic can be
annotated with a hint (referred to as a &#8220;fix-it hint&#8221;) that describes how to
change the code referenced by the diagnostic to fix the problem.  For example,
it might add the missing semicolon at the end of the statement or rewrite the
use of a deprecated construct into something more palatable.  Here is one such
example from the C++ front end, where we warn about the right-shift operator
changing meaning from C++98 to C++11:</p>
<div class="highlight-c++"><div class="highlight"><pre>test.cpp:3:7: warning: use of right-shift operator (&#39;&gt;&gt;&#39;) in template argument
                       will require parentheses in C++11
A&lt;100 &gt;&gt; 2&gt; *a;
      ^
  (       )
</pre></div>
</div>
<p>Here, the fix-it hint is suggesting that parentheses be added, and showing
exactly where those parentheses would be inserted into the source code.  The
fix-it hints themselves describe what changes to make to the source code in an
abstract manner, which the text diagnostic printer renders as a line of
&#8220;insertions&#8221; below the caret line.  <a class="reference internal" href="#diagnosticclient"><span>Other diagnostic clients</span></a> might choose to render the code differently (e.g., as
markup inline) or even give the user the ability to automatically fix the
problem.</p>
<p>Fix-it hints on errors and warnings need to obey these rules:</p>
<ul class="simple">
<li>Since they are automatically applied if <code class="docutils literal"><span class="pre">-Xclang</span> <span class="pre">-fixit</span></code> is passed to the
driver, they should only be used when it&#8217;s very likely they match the user&#8217;s
intent.</li>
<li>Clang must recover from errors as if the fix-it had been applied.</li>
</ul>
<p>If a fix-it can&#8217;t obey these rules, put the fix-it on a note.  Fix-its on notes
are not applied automatically.</p>
<p>All fix-it hints are described by the <code class="docutils literal"><span class="pre">FixItHint</span></code> class, instances of which
should be attached to the diagnostic using the <code class="docutils literal"><span class="pre">&lt;&lt;</span></code> operator in the same way
that highlighted source ranges and arguments are passed to the diagnostic.
Fix-it hints can be created with one of three constructors:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">FixItHint::CreateInsertion(Loc,</span> <span class="pre">Code)</span></code></p>
<blockquote>
<div><p>Specifies that the given <code class="docutils literal"><span class="pre">Code</span></code> (a string) should be inserted before the
source location <code class="docutils literal"><span class="pre">Loc</span></code>.</p>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">FixItHint::CreateRemoval(Range)</span></code></p>
<blockquote>
<div><p>Specifies that the code in the given source <code class="docutils literal"><span class="pre">Range</span></code> should be removed.</p>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">FixItHint::CreateReplacement(Range,</span> <span class="pre">Code)</span></code></p>
<blockquote>
<div><p>Specifies that the code in the given source <code class="docutils literal"><span class="pre">Range</span></code> should be removed,
and replaced with the given <code class="docutils literal"><span class="pre">Code</span></code> string.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="the-diagnosticclient-interface">
<span id="diagnosticclient"></span><h4><a class="toc-backref" href="#id12">The <code class="docutils literal"><span class="pre">DiagnosticClient</span></code> Interface</a><a class="headerlink" href="#the-diagnosticclient-interface" title="Permalink to this headline">¶</a></h4>
<p>Once code generates a diagnostic with all of the arguments and the rest of the
relevant information, Clang needs to know what to do with it.  As previously
mentioned, the diagnostic machinery goes through some filtering to map a
severity onto a diagnostic level, then (assuming the diagnostic is not mapped
to &#8220;<code class="docutils literal"><span class="pre">Ignore</span></code>&#8221;) it invokes an object that implements the <code class="docutils literal"><span class="pre">DiagnosticClient</span></code>
interface with the information.</p>
<p>It is possible to implement this interface in many different ways.  For
example, the normal Clang <code class="docutils literal"><span class="pre">DiagnosticClient</span></code> (named
<code class="docutils literal"><span class="pre">TextDiagnosticPrinter</span></code>) turns the arguments into strings (according to the
various formatting rules), prints out the file/line/column information and the
string, then prints out the line of code, the source ranges, and the caret.
However, this behavior isn&#8217;t required.</p>
<p>Another implementation of the <code class="docutils literal"><span class="pre">DiagnosticClient</span></code> interface is the
<code class="docutils literal"><span class="pre">TextDiagnosticBuffer</span></code> class, which is used when Clang is in <code class="docutils literal"><span class="pre">-verify</span></code>
mode.  Instead of formatting and printing out the diagnostics, this
implementation just captures and remembers the diagnostics as they fly by.
Then <code class="docutils literal"><span class="pre">-verify</span></code> compares the list of produced diagnostics to the list of
expected ones.  If they disagree, it prints out its own output.  Full
documentation for the <code class="docutils literal"><span class="pre">-verify</span></code> mode can be found in the Clang API
documentation for <a class="reference external" href="/doxygen/classclang_1_1VerifyDiagnosticConsumer.html#details">VerifyDiagnosticConsumer</a>.</p>
<p>There are many other possible implementations of this interface, and this is
why we prefer diagnostics to pass down rich structured information in
arguments.  For example, an HTML output might want declaration names be
linkified to where they come from in the source.  Another example is that a GUI
might let you click on typedefs to expand them.  This application would want to
pass significantly more information about types through to the GUI than a
simple flat string.  The interface allows this to happen.</p>
</div>
<div class="section" id="adding-translations-to-clang">
<span id="internals-diag-translation"></span><h4><a class="toc-backref" href="#id13">Adding Translations to Clang</a><a class="headerlink" href="#adding-translations-to-clang" title="Permalink to this headline">¶</a></h4>
<p>Not possible yet! Diagnostic strings should be written in UTF-8, the client can
translate to the relevant code page if needed.  Each translation completely
replaces the format string for the diagnostic.</p>
</div>
</div>
<div class="section" id="the-sourcelocation-and-sourcemanager-classes">
<span id="sourcemanager"></span><span id="sourcelocation"></span><h3><a class="toc-backref" href="#id14">The <code class="docutils literal"><span class="pre">SourceLocation</span></code> and <code class="docutils literal"><span class="pre">SourceManager</span></code> classes</a><a class="headerlink" href="#the-sourcelocation-and-sourcemanager-classes" title="Permalink to this headline">¶</a></h3>
<p>Strangely enough, the <code class="docutils literal"><span class="pre">SourceLocation</span></code> class represents a location within the
source code of the program.  Important design points include:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">sizeof(SourceLocation)</span></code> must be extremely small, as these are embedded
into many AST nodes and are passed around often.  Currently it is 32 bits.</li>
<li><code class="docutils literal"><span class="pre">SourceLocation</span></code> must be a simple value object that can be efficiently
copied.</li>
<li>We should be able to represent a source location for any byte of any input
file.  This includes in the middle of tokens, in whitespace, in trigraphs,
etc.</li>
<li>A <code class="docutils literal"><span class="pre">SourceLocation</span></code> must encode the current <code class="docutils literal"><span class="pre">#include</span></code> stack that was
active when the location was processed.  For example, if the location
corresponds to a token, it should contain the set of <code class="docutils literal"><span class="pre">#include</span></code>s active
when the token was lexed.  This allows us to print the <code class="docutils literal"><span class="pre">#include</span></code> stack
for a diagnostic.</li>
<li><code class="docutils literal"><span class="pre">SourceLocation</span></code> must be able to describe macro expansions, capturing both
the ultimate instantiation point and the source of the original character
data.</li>
</ol>
<p>In practice, the <code class="docutils literal"><span class="pre">SourceLocation</span></code> works together with the <code class="docutils literal"><span class="pre">SourceManager</span></code>
class to encode two pieces of information about a location: its spelling
location and its instantiation location.  For most tokens, these will be the
same.  However, for a macro expansion (or tokens that came from a <code class="docutils literal"><span class="pre">_Pragma</span></code>
directive) these will describe the location of the characters corresponding to
the token and the location where the token was used (i.e., the macro
instantiation point or the location of the <code class="docutils literal"><span class="pre">_Pragma</span></code> itself).</p>
<p>The Clang front-end inherently depends on the location of a token being tracked
correctly.  If it is ever incorrect, the front-end may get confused and die.
The reason for this is that the notion of the &#8220;spelling&#8221; of a <code class="docutils literal"><span class="pre">Token</span></code> in
Clang depends on being able to find the original input characters for the
token.  This concept maps directly to the &#8220;spelling location&#8221; for the token.</p>
</div>
<div class="section" id="sourcerange-and-charsourcerange">
<h3><a class="toc-backref" href="#id15"><code class="docutils literal"><span class="pre">SourceRange</span></code> and <code class="docutils literal"><span class="pre">CharSourceRange</span></code></a><a class="headerlink" href="#sourcerange-and-charsourcerange" title="Permalink to this headline">¶</a></h3>
<p>Clang represents most source ranges by [first, last], where &#8220;first&#8221; and &#8220;last&#8221;
each point to the beginning of their respective tokens.  For example consider
the <code class="docutils literal"><span class="pre">SourceRange</span></code> of the following statement:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="n">bar</span><span class="p">;</span>
<span class="o">^</span><span class="n">first</span>    <span class="o">^</span><span class="n">last</span>
</pre></div>
</div>
<p>To map from this representation to a character-based representation, the &#8220;last&#8221;
location needs to be adjusted to point to (or past) the end of that token with
either <code class="docutils literal"><span class="pre">Lexer::MeasureTokenLength()</span></code> or <code class="docutils literal"><span class="pre">Lexer::getLocForEndOfToken()</span></code>.  For
the rare cases where character-level source ranges information is needed we use
the <code class="docutils literal"><span class="pre">CharSourceRange</span></code> class.</p>
</div>
</div>
<div class="section" id="the-driver-library">
<h2><a class="toc-backref" href="#id16">The Driver Library</a><a class="headerlink" href="#the-driver-library" title="Permalink to this headline">¶</a></h2>
<p>The clang Driver and library are documented <a class="reference internal" href="DriverInternals.html"><em>here</em></a>.</p>
</div>
<div class="section" id="precompiled-headers">
<h2><a class="toc-backref" href="#id17">Precompiled Headers</a><a class="headerlink" href="#precompiled-headers" title="Permalink to this headline">¶</a></h2>
<p>Clang supports two implementations of precompiled headers.  The default
implementation, precompiled headers (<a class="reference internal" href="PCHInternals.html"><em>PCH</em></a>) uses a
serialized representation of Clang&#8217;s internal data structures, encoded with the
<a class="reference external" href="http://llvm.org/docs/BitCodeFormat.html">LLVM bitstream format</a>.
Pretokenized headers (<a class="reference internal" href="PTHInternals.html"><em>PTH</em></a>), on the other hand, contain a
serialized representation of the tokens encountered when preprocessing a header
(and anything that header includes).</p>
</div>
<div class="section" id="the-frontend-library">
<h2><a class="toc-backref" href="#id18">The Frontend Library</a><a class="headerlink" href="#the-frontend-library" title="Permalink to this headline">¶</a></h2>
<p>The Frontend library contains functionality useful for building tools on top of
the Clang libraries, for example several methods for outputting diagnostics.</p>
</div>
<div class="section" id="the-lexer-and-preprocessor-library">
<h2><a class="toc-backref" href="#id19">The Lexer and Preprocessor Library</a><a class="headerlink" href="#the-lexer-and-preprocessor-library" title="Permalink to this headline">¶</a></h2>
<p>The Lexer library contains several tightly-connected classes that are involved
with the nasty process of lexing and preprocessing C source code.  The main
interface to this library for outside clients is the large <code class="docutils literal"><span class="pre">Preprocessor</span></code>
class.  It contains the various pieces of state that are required to coherently
read tokens out of a translation unit.</p>
<p>The core interface to the <code class="docutils literal"><span class="pre">Preprocessor</span></code> object (once it is set up) is the
<code class="docutils literal"><span class="pre">Preprocessor::Lex</span></code> method, which returns the next <a class="reference internal" href="#token"><span>Token</span></a> from
the preprocessor stream.  There are two types of token providers that the
preprocessor is capable of reading from: a buffer lexer (provided by the
<a class="reference internal" href="#lexer"><span>Lexer</span></a> class) and a buffered token stream (provided by the
<a class="reference internal" href="#tokenlexer"><span>TokenLexer</span></a> class).</p>
<div class="section" id="the-token-class">
<span id="token"></span><h3><a class="toc-backref" href="#id20">The Token class</a><a class="headerlink" href="#the-token-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">Token</span></code> class is used to represent a single lexed token.  Tokens are
intended to be used by the lexer/preprocess and parser libraries, but are not
intended to live beyond them (for example, they should not live in the ASTs).</p>
<p>Tokens most often live on the stack (or some other location that is efficient
to access) as the parser is running, but occasionally do get buffered up.  For
example, macro definitions are stored as a series of tokens, and the C++
front-end periodically needs to buffer tokens up for tentative parsing and
various pieces of look-ahead.  As such, the size of a <code class="docutils literal"><span class="pre">Token</span></code> matters.  On a
32-bit system, <code class="docutils literal"><span class="pre">sizeof(Token)</span></code> is currently 16 bytes.</p>
<p>Tokens occur in two forms: <a class="reference internal" href="#annotationtoken"><span>annotation tokens</span></a> and
normal tokens.  Normal tokens are those returned by the lexer, annotation
tokens represent semantic information and are produced by the parser, replacing
normal tokens in the token stream.  Normal tokens contain the following
information:</p>
<ul class="simple">
<li><strong>A SourceLocation</strong> &#8212; This indicates the location of the start of the
token.</li>
<li><strong>A length</strong> &#8212; This stores the length of the token as stored in the
<code class="docutils literal"><span class="pre">SourceBuffer</span></code>.  For tokens that include them, this length includes
trigraphs and escaped newlines which are ignored by later phases of the
compiler.  By pointing into the original source buffer, it is always possible
to get the original spelling of a token completely accurately.</li>
<li><strong>IdentifierInfo</strong> &#8212; If a token takes the form of an identifier, and if
identifier lookup was enabled when the token was lexed (e.g., the lexer was
not reading in &#8220;raw&#8221; mode) this contains a pointer to the unique hash value
for the identifier.  Because the lookup happens before keyword
identification, this field is set even for language keywords like &#8220;<code class="docutils literal"><span class="pre">for</span></code>&#8221;.</li>
<li><strong>TokenKind</strong> &#8212; This indicates the kind of token as classified by the
lexer.  This includes things like <code class="docutils literal"><span class="pre">tok::starequal</span></code> (for the &#8220;<code class="docutils literal"><span class="pre">*=</span></code>&#8221;
operator), <code class="docutils literal"><span class="pre">tok::ampamp</span></code> for the &#8220;<code class="docutils literal"><span class="pre">&amp;&amp;</span></code>&#8221; token, and keyword values (e.g.,
<code class="docutils literal"><span class="pre">tok::kw_for</span></code>) for identifiers that correspond to keywords.  Note that
some tokens can be spelled multiple ways.  For example, C++ supports
&#8220;operator keywords&#8221;, where things like &#8220;<code class="docutils literal"><span class="pre">and</span></code>&#8221; are treated exactly like the
&#8220;<code class="docutils literal"><span class="pre">&amp;&amp;</span></code>&#8221; operator.  In these cases, the kind value is set to <code class="docutils literal"><span class="pre">tok::ampamp</span></code>,
which is good for the parser, which doesn&#8217;t have to consider both forms.  For
something that cares about which form is used (e.g., the preprocessor
&#8220;stringize&#8221; operator) the spelling indicates the original form.</li>
<li><strong>Flags</strong> &#8212; There are currently four flags tracked by the
lexer/preprocessor system on a per-token basis:<ol class="arabic">
<li><strong>StartOfLine</strong> &#8212; This was the first token that occurred on its input
source line.</li>
<li><strong>LeadingSpace</strong> &#8212; There was a space character either immediately before
the token or transitively before the token as it was expanded through a
macro.  The definition of this flag is very closely defined by the
stringizing requirements of the preprocessor.</li>
<li><strong>DisableExpand</strong> &#8212; This flag is used internally to the preprocessor to
represent identifier tokens which have macro expansion disabled.  This
prevents them from being considered as candidates for macro expansion ever
in the future.</li>
<li><strong>NeedsCleaning</strong> &#8212; This flag is set if the original spelling for the
token includes a trigraph or escaped newline.  Since this is uncommon,
many pieces of code can fast-path on tokens that did not need cleaning.</li>
</ol>
</li>
</ul>
<p>One interesting (and somewhat unusual) aspect of normal tokens is that they
don&#8217;t contain any semantic information about the lexed value.  For example, if
the token was a pp-number token, we do not represent the value of the number
that was lexed (this is left for later pieces of code to decide).
Additionally, the lexer library has no notion of typedef names vs variable
names: both are returned as identifiers, and the parser is left to decide
whether a specific identifier is a typedef or a variable (tracking this
requires scope information among other things).  The parser can do this
translation by replacing tokens returned by the preprocessor with &#8220;Annotation
Tokens&#8221;.</p>
</div>
<div class="section" id="annotation-tokens">
<span id="annotationtoken"></span><h3><a class="toc-backref" href="#id21">Annotation Tokens</a><a class="headerlink" href="#annotation-tokens" title="Permalink to this headline">¶</a></h3>
<p>Annotation tokens are tokens that are synthesized by the parser and injected
into the preprocessor&#8217;s token stream (replacing existing tokens) to record
semantic information found by the parser.  For example, if &#8220;<code class="docutils literal"><span class="pre">foo</span></code>&#8221; is found
to be a typedef, the &#8220;<code class="docutils literal"><span class="pre">foo</span></code>&#8221; <code class="docutils literal"><span class="pre">tok::identifier</span></code> token is replaced with an
<code class="docutils literal"><span class="pre">tok::annot_typename</span></code>.  This is useful for a couple of reasons: 1) this makes
it easy to handle qualified type names (e.g., &#8220;<code class="docutils literal"><span class="pre">foo::bar::baz&lt;42&gt;::t</span></code>&#8221;) in
C++ as a single &#8220;token&#8221; in the parser.  2) if the parser backtracks, the
reparse does not need to redo semantic analysis to determine whether a token
sequence is a variable, type, template, etc.</p>
<p>Annotation tokens are created by the parser and reinjected into the parser&#8217;s
token stream (when backtracking is enabled).  Because they can only exist in
tokens that the preprocessor-proper is done with, it doesn&#8217;t need to keep
around flags like &#8220;start of line&#8221; that the preprocessor uses to do its job.
Additionally, an annotation token may &#8220;cover&#8221; a sequence of preprocessor tokens
(e.g., &#8220;<code class="docutils literal"><span class="pre">a::b::c</span></code>&#8221; is five preprocessor tokens).  As such, the valid fields
of an annotation token are different than the fields for a normal token (but
they are multiplexed into the normal <code class="docutils literal"><span class="pre">Token</span></code> fields):</p>
<ul class="simple">
<li><strong>SourceLocation &#8220;Location&#8221;</strong> &#8212; The <code class="docutils literal"><span class="pre">SourceLocation</span></code> for the annotation
token indicates the first token replaced by the annotation token.  In the
example above, it would be the location of the &#8220;<code class="docutils literal"><span class="pre">a</span></code>&#8221; identifier.</li>
<li><strong>SourceLocation &#8220;AnnotationEndLoc&#8221;</strong> &#8212; This holds the location of the last
token replaced with the annotation token.  In the example above, it would be
the location of the &#8220;<code class="docutils literal"><span class="pre">c</span></code>&#8221; identifier.</li>
<li><strong>void* &#8220;AnnotationValue&#8221;</strong> &#8212; This contains an opaque object that the
parser gets from <code class="docutils literal"><span class="pre">Sema</span></code>.  The parser merely preserves the information for
<code class="docutils literal"><span class="pre">Sema</span></code> to later interpret based on the annotation token kind.</li>
<li><strong>TokenKind &#8220;Kind&#8221;</strong> &#8212; This indicates the kind of Annotation token this is.
See below for the different valid kinds.</li>
</ul>
<p>Annotation tokens currently come in three kinds:</p>
<ol class="arabic simple">
<li><strong>tok::annot_typename</strong>: This annotation token represents a resolved
typename token that is potentially qualified.  The <code class="docutils literal"><span class="pre">AnnotationValue</span></code> field
contains the <code class="docutils literal"><span class="pre">QualType</span></code> returned by <code class="docutils literal"><span class="pre">Sema::getTypeName()</span></code>, possibly with
source location information attached.</li>
<li><strong>tok::annot_cxxscope</strong>: This annotation token represents a C++ scope
specifier, such as &#8220;<code class="docutils literal"><span class="pre">A::B::</span></code>&#8221;.  This corresponds to the grammar
productions &#8220;<em>::</em>&#8221; and &#8220;<em>:: [opt] nested-name-specifier</em>&#8221;.  The
<code class="docutils literal"><span class="pre">AnnotationValue</span></code> pointer is a <code class="docutils literal"><span class="pre">NestedNameSpecifier</span> <span class="pre">*</span></code> returned by the
<code class="docutils literal"><span class="pre">Sema::ActOnCXXGlobalScopeSpecifier</span></code> and
<code class="docutils literal"><span class="pre">Sema::ActOnCXXNestedNameSpecifier</span></code> callbacks.</li>
<li><strong>tok::annot_template_id</strong>: This annotation token represents a C++
template-id such as &#8220;<code class="docutils literal"><span class="pre">foo&lt;int,</span> <span class="pre">4&gt;</span></code>&#8221;, where &#8220;<code class="docutils literal"><span class="pre">foo</span></code>&#8221; is the name of a
template.  The <code class="docutils literal"><span class="pre">AnnotationValue</span></code> pointer is a pointer to a <code class="docutils literal"><span class="pre">malloc</span></code>&#8216;d
<code class="docutils literal"><span class="pre">TemplateIdAnnotation</span></code> object.  Depending on the context, a parsed
template-id that names a type might become a typename annotation token (if
all we care about is the named type, e.g., because it occurs in a type
specifier) or might remain a template-id token (if we want to retain more
source location information or produce a new type, e.g., in a declaration of
a class template specialization).  template-id annotation tokens that refer
to a type can be &#8220;upgraded&#8221; to typename annotation tokens by the parser.</li>
</ol>
<p>As mentioned above, annotation tokens are not returned by the preprocessor,
they are formed on demand by the parser.  This means that the parser has to be
aware of cases where an annotation could occur and form it where appropriate.
This is somewhat similar to how the parser handles Translation Phase 6 of C99:
String Concatenation (see C99 5.1.1.2).  In the case of string concatenation,
the preprocessor just returns distinct <code class="docutils literal"><span class="pre">tok::string_literal</span></code> and
<code class="docutils literal"><span class="pre">tok::wide_string_literal</span></code> tokens and the parser eats a sequence of them
wherever the grammar indicates that a string literal can occur.</p>
<p>In order to do this, whenever the parser expects a <code class="docutils literal"><span class="pre">tok::identifier</span></code> or
<code class="docutils literal"><span class="pre">tok::coloncolon</span></code>, it should call the <code class="docutils literal"><span class="pre">TryAnnotateTypeOrScopeToken</span></code> or
<code class="docutils literal"><span class="pre">TryAnnotateCXXScopeToken</span></code> methods to form the annotation token.  These
methods will maximally form the specified annotation tokens and replace the
current token with them, if applicable.  If the current tokens is not valid for
an annotation token, it will remain an identifier or &#8220;<code class="docutils literal"><span class="pre">::</span></code>&#8221; token.</p>
</div>
<div class="section" id="the-lexer-class">
<span id="lexer"></span><h3><a class="toc-backref" href="#id22">The <code class="docutils literal"><span class="pre">Lexer</span></code> class</a><a class="headerlink" href="#the-lexer-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">Lexer</span></code> class provides the mechanics of lexing tokens out of a source
buffer and deciding what they mean.  The <code class="docutils literal"><span class="pre">Lexer</span></code> is complicated by the fact
that it operates on raw buffers that have not had spelling eliminated (this is
a necessity to get decent performance), but this is countered with careful
coding as well as standard performance techniques (for example, the comment
handling code is vectorized on X86 and PowerPC hosts).</p>
<p>The lexer has a couple of interesting modal features:</p>
<ul class="simple">
<li>The lexer can operate in &#8220;raw&#8221; mode.  This mode has several features that
make it possible to quickly lex the file (e.g., it stops identifier lookup,
doesn&#8217;t specially handle preprocessor tokens, handles EOF differently, etc).
This mode is used for lexing within an &#8220;<code class="docutils literal"><span class="pre">#if</span> <span class="pre">0</span></code>&#8221; block, for example.</li>
<li>The lexer can capture and return comments as tokens.  This is required to
support the <code class="docutils literal"><span class="pre">-C</span></code> preprocessor mode, which passes comments through, and is
used by the diagnostic checker to identifier expect-error annotations.</li>
<li>The lexer can be in <code class="docutils literal"><span class="pre">ParsingFilename</span></code> mode, which happens when
preprocessing after reading a <code class="docutils literal"><span class="pre">#include</span></code> directive.  This mode changes the
parsing of &#8220;<code class="docutils literal"><span class="pre">&lt;</span></code>&#8221; to return an &#8220;angled string&#8221; instead of a bunch of tokens
for each thing within the filename.</li>
<li>When parsing a preprocessor directive (after &#8220;<code class="docutils literal"><span class="pre">#</span></code>&#8221;) the
<code class="docutils literal"><span class="pre">ParsingPreprocessorDirective</span></code> mode is entered.  This changes the parser to
return EOD at a newline.</li>
<li>The <code class="docutils literal"><span class="pre">Lexer</span></code> uses a <code class="docutils literal"><span class="pre">LangOptions</span></code> object to know whether trigraphs are
enabled, whether C++ or ObjC keywords are recognized, etc.</li>
</ul>
<p>In addition to these modes, the lexer keeps track of a couple of other features
that are local to a lexed buffer, which change as the buffer is lexed:</p>
<ul class="simple">
<li>The <code class="docutils literal"><span class="pre">Lexer</span></code> uses <code class="docutils literal"><span class="pre">BufferPtr</span></code> to keep track of the current character being
lexed.</li>
<li>The <code class="docutils literal"><span class="pre">Lexer</span></code> uses <code class="docutils literal"><span class="pre">IsAtStartOfLine</span></code> to keep track of whether the next
lexed token will start with its &#8220;start of line&#8221; bit set.</li>
<li>The <code class="docutils literal"><span class="pre">Lexer</span></code> keeps track of the current &#8220;<code class="docutils literal"><span class="pre">#if</span></code>&#8221; directives that are active
(which can be nested).</li>
<li>The <code class="docutils literal"><span class="pre">Lexer</span></code> keeps track of an <a class="reference internal" href="#multipleincludeopt"><span>MultipleIncludeOpt</span></a> object, which is used to detect whether the buffer uses
the standard &#8220;<code class="docutils literal"><span class="pre">#ifndef</span> <span class="pre">XX</span></code> / <code class="docutils literal"><span class="pre">#define</span> <span class="pre">XX</span></code>&#8221; idiom to prevent multiple
inclusion.  If a buffer does, subsequent includes can be ignored if the
&#8220;<code class="docutils literal"><span class="pre">XX</span></code>&#8221; macro is defined.</li>
</ul>
</div>
<div class="section" id="the-tokenlexer-class">
<span id="tokenlexer"></span><h3><a class="toc-backref" href="#id23">The <code class="docutils literal"><span class="pre">TokenLexer</span></code> class</a><a class="headerlink" href="#the-tokenlexer-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">TokenLexer</span></code> class is a token provider that returns tokens from a list of
tokens that came from somewhere else.  It typically used for two things: 1)
returning tokens from a macro definition as it is being expanded 2) returning
tokens from an arbitrary buffer of tokens.  The later use is used by
<code class="docutils literal"><span class="pre">_Pragma</span></code> and will most likely be used to handle unbounded look-ahead for the
C++ parser.</p>
</div>
<div class="section" id="the-multipleincludeopt-class">
<span id="multipleincludeopt"></span><h3><a class="toc-backref" href="#id24">The <code class="docutils literal"><span class="pre">MultipleIncludeOpt</span></code> class</a><a class="headerlink" href="#the-multipleincludeopt-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">MultipleIncludeOpt</span></code> class implements a really simple little state
machine that is used to detect the standard &#8220;<code class="docutils literal"><span class="pre">#ifndef</span> <span class="pre">XX</span></code> / <code class="docutils literal"><span class="pre">#define</span> <span class="pre">XX</span></code>&#8221;
idiom that people typically use to prevent multiple inclusion of headers.  If a
buffer uses this idiom and is subsequently <code class="docutils literal"><span class="pre">#include</span></code>&#8216;d, the preprocessor can
simply check to see whether the guarding condition is defined or not.  If so,
the preprocessor can completely ignore the include of the header.</p>
</div>
</div>
<div class="section" id="the-parser-library">
<span id="parser"></span><h2><a class="toc-backref" href="#id25">The Parser Library</a><a class="headerlink" href="#the-parser-library" title="Permalink to this headline">¶</a></h2>
<p>This library contains a recursive-descent parser that polls tokens from the
preprocessor and notifies a client of the parsing progress.</p>
<p>Historically, the parser used to talk to an abstract <code class="docutils literal"><span class="pre">Action</span></code> interface that
had virtual methods for parse events, for example <code class="docutils literal"><span class="pre">ActOnBinOp()</span></code>.  When Clang
grew C++ support, the parser stopped supporting general <code class="docutils literal"><span class="pre">Action</span></code> clients &#8211;
it now always talks to the <a class="reference internal" href="#sema"><span>Sema libray</span></a>.  However, the Parser
still accesses AST objects only through opaque types like <code class="docutils literal"><span class="pre">ExprResult</span></code> and
<code class="docutils literal"><span class="pre">StmtResult</span></code>.  Only <a class="reference internal" href="#sema"><span>Sema</span></a> looks at the AST node contents of these
wrappers.</p>
</div>
<div class="section" id="the-ast-library">
<span id="ast"></span><h2><a class="toc-backref" href="#id26">The AST Library</a><a class="headerlink" href="#the-ast-library" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-type-class-and-its-subclasses">
<span id="type"></span><h3><a class="toc-backref" href="#id27">The <code class="docutils literal"><span class="pre">Type</span></code> class and its subclasses</a><a class="headerlink" href="#the-type-class-and-its-subclasses" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">Type</span></code> class (and its subclasses) are an important part of the AST.
Types are accessed through the <code class="docutils literal"><span class="pre">ASTContext</span></code> class, which implicitly creates
and uniques them as they are needed.  Types have a couple of non-obvious
features: 1) they do not capture type qualifiers like <code class="docutils literal"><span class="pre">const</span></code> or <code class="docutils literal"><span class="pre">volatile</span></code>
(see <a class="reference internal" href="#qualtype"><span>QualType</span></a>), and 2) they implicitly capture typedef
information.  Once created, types are immutable (unlike decls).</p>
<p>Typedefs in C make semantic analysis a bit more complex than it would be without
them.  The issue is that we want to capture typedef information and represent it
in the AST perfectly, but the semantics of operations need to &#8220;see through&#8221;
typedefs.  For example, consider this code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">foo</span> <span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">Y</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">foo</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>
  <span class="n">bar</span> <span class="n">Z</span><span class="p">;</span>
  <span class="o">*</span><span class="n">X</span><span class="p">;</span> <span class="c1">// error</span>
  <span class="o">**</span><span class="n">Y</span><span class="p">;</span> <span class="c1">// error</span>
  <span class="o">**</span><span class="n">Z</span><span class="p">;</span> <span class="c1">// error</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The code above is illegal, and thus we expect there to be diagnostics emitted
on the annotated lines.  In this example, we expect to get:</p>
<div class="highlight-c++"><div class="highlight"><pre>test.c:6:1: error: indirection requires pointer operand (&#39;foo&#39; invalid)
  *X; // error
  ^~
test.c:7:1: error: indirection requires pointer operand (&#39;foo&#39; invalid)
  **Y; // error
  ^~~
test.c:8:1: error: indirection requires pointer operand (&#39;foo&#39; invalid)
  **Z; // error
  ^~~
</pre></div>
</div>
<p>While this example is somewhat silly, it illustrates the point: we want to
retain typedef information where possible, so that we can emit errors about
&#8220;<code class="docutils literal"><span class="pre">std::string</span></code>&#8221; instead of &#8220;<code class="docutils literal"><span class="pre">std::basic_string&lt;char,</span> <span class="pre">std:...</span></code>&#8221;.  Doing this
requires properly keeping typedef information (for example, the type of <code class="docutils literal"><span class="pre">X</span></code>
is &#8220;<code class="docutils literal"><span class="pre">foo</span></code>&#8221;, not &#8220;<code class="docutils literal"><span class="pre">int</span></code>&#8221;), and requires properly propagating it through the
various operators (for example, the type of <code class="docutils literal"><span class="pre">*Y</span></code> is &#8220;<code class="docutils literal"><span class="pre">foo</span></code>&#8221;, not
&#8220;<code class="docutils literal"><span class="pre">int</span></code>&#8221;).  In order to retain this information, the type of these expressions
is an instance of the <code class="docutils literal"><span class="pre">TypedefType</span></code> class, which indicates that the type of
these expressions is a typedef for &#8220;<code class="docutils literal"><span class="pre">foo</span></code>&#8221;.</p>
<p>Representing types like this is great for diagnostics, because the
user-specified type is always immediately available.  There are two problems
with this: first, various semantic checks need to make judgements about the
<em>actual structure</em> of a type, ignoring typedefs.  Second, we need an efficient
way to query whether two types are structurally identical to each other,
ignoring typedefs.  The solution to both of these problems is the idea of
canonical types.</p>
<div class="section" id="canonical-types">
<h4><a class="toc-backref" href="#id28">Canonical Types</a><a class="headerlink" href="#canonical-types" title="Permalink to this headline">¶</a></h4>
<p>Every instance of the <code class="docutils literal"><span class="pre">Type</span></code> class contains a canonical type pointer.  For
simple types with no typedefs involved (e.g., &#8220;<code class="docutils literal"><span class="pre">int</span></code>&#8221;, &#8220;<code class="docutils literal"><span class="pre">int*</span></code>&#8221;,
&#8220;<code class="docutils literal"><span class="pre">int**</span></code>&#8221;), the type just points to itself.  For types that have a typedef
somewhere in their structure (e.g., &#8220;<code class="docutils literal"><span class="pre">foo</span></code>&#8221;, &#8220;<code class="docutils literal"><span class="pre">foo*</span></code>&#8221;, &#8220;<code class="docutils literal"><span class="pre">foo**</span></code>&#8221;,
&#8220;<code class="docutils literal"><span class="pre">bar</span></code>&#8221;), the canonical type pointer points to their structurally equivalent
type without any typedefs (e.g., &#8220;<code class="docutils literal"><span class="pre">int</span></code>&#8221;, &#8220;<code class="docutils literal"><span class="pre">int*</span></code>&#8221;, &#8220;<code class="docutils literal"><span class="pre">int**</span></code>&#8221;, and
&#8220;<code class="docutils literal"><span class="pre">int*</span></code>&#8221; respectively).</p>
<p>This design provides a constant time operation (dereferencing the canonical type
pointer) that gives us access to the structure of types.  For example, we can
trivially tell that &#8220;<code class="docutils literal"><span class="pre">bar</span></code>&#8221; and &#8220;<code class="docutils literal"><span class="pre">foo*</span></code>&#8221; are the same type by dereferencing
their canonical type pointers and doing a pointer comparison (they both point
to the single &#8220;<code class="docutils literal"><span class="pre">int*</span></code>&#8221; type).</p>
<p>Canonical types and typedef types bring up some complexities that must be
carefully managed.  Specifically, the <code class="docutils literal"><span class="pre">isa</span></code>/<code class="docutils literal"><span class="pre">cast</span></code>/<code class="docutils literal"><span class="pre">dyn_cast</span></code> operators
generally shouldn&#8217;t be used in code that is inspecting the AST.  For example,
when type checking the indirection operator (unary &#8220;<code class="docutils literal"><span class="pre">*</span></code>&#8221; on a pointer), the
type checker must verify that the operand has a pointer type.  It would not be
correct to check that with &#8220;<code class="docutils literal"><span class="pre">isa&lt;PointerType&gt;(SubExpr-&gt;getType())</span></code>&#8221;, because
this predicate would fail if the subexpression had a typedef type.</p>
<p>The solution to this problem are a set of helper methods on <code class="docutils literal"><span class="pre">Type</span></code>, used to
check their properties.  In this case, it would be correct to use
&#8220;<code class="docutils literal"><span class="pre">SubExpr-&gt;getType()-&gt;isPointerType()</span></code>&#8221; to do the check.  This predicate will
return true if the <em>canonical type is a pointer</em>, which is true any time the
type is structurally a pointer type.  The only hard part here is remembering
not to use the <code class="docutils literal"><span class="pre">isa</span></code>/<code class="docutils literal"><span class="pre">cast</span></code>/<code class="docutils literal"><span class="pre">dyn_cast</span></code> operations.</p>
<p>The second problem we face is how to get access to the pointer type once we
know it exists.  To continue the example, the result type of the indirection
operator is the pointee type of the subexpression.  In order to determine the
type, we need to get the instance of <code class="docutils literal"><span class="pre">PointerType</span></code> that best captures the
typedef information in the program.  If the type of the expression is literally
a <code class="docutils literal"><span class="pre">PointerType</span></code>, we can return that, otherwise we have to dig through the
typedefs to find the pointer type.  For example, if the subexpression had type
&#8220;<code class="docutils literal"><span class="pre">foo*</span></code>&#8221;, we could return that type as the result.  If the subexpression had
type &#8220;<code class="docutils literal"><span class="pre">bar</span></code>&#8221;, we want to return &#8220;<code class="docutils literal"><span class="pre">foo*</span></code>&#8221; (note that we do <em>not</em> want
&#8220;<code class="docutils literal"><span class="pre">int*</span></code>&#8221;).  In order to provide all of this, <code class="docutils literal"><span class="pre">Type</span></code> has a
<code class="docutils literal"><span class="pre">getAsPointerType()</span></code> method that checks whether the type is structurally a
<code class="docutils literal"><span class="pre">PointerType</span></code> and, if so, returns the best one.  If not, it returns a null
pointer.</p>
<p>This structure is somewhat mystical, but after meditating on it, it will make
sense to you :).</p>
</div>
</div>
<div class="section" id="the-qualtype-class">
<span id="qualtype"></span><h3><a class="toc-backref" href="#id29">The <code class="docutils literal"><span class="pre">QualType</span></code> class</a><a class="headerlink" href="#the-qualtype-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">QualType</span></code> class is designed as a trivial value class that is small,
passed by-value and is efficient to query.  The idea of <code class="docutils literal"><span class="pre">QualType</span></code> is that it
stores the type qualifiers (<code class="docutils literal"><span class="pre">const</span></code>, <code class="docutils literal"><span class="pre">volatile</span></code>, <code class="docutils literal"><span class="pre">restrict</span></code>, plus some
extended qualifiers required by language extensions) separately from the types
themselves.  <code class="docutils literal"><span class="pre">QualType</span></code> is conceptually a pair of &#8220;<code class="docutils literal"><span class="pre">Type*</span></code>&#8221; and the bits
for these type qualifiers.</p>
<p>By storing the type qualifiers as bits in the conceptual pair, it is extremely
efficient to get the set of qualifiers on a <code class="docutils literal"><span class="pre">QualType</span></code> (just return the field
of the pair), add a type qualifier (which is a trivial constant-time operation
that sets a bit), and remove one or more type qualifiers (just return a
<code class="docutils literal"><span class="pre">QualType</span></code> with the bitfield set to empty).</p>
<p>Further, because the bits are stored outside of the type itself, we do not need
to create duplicates of types with different sets of qualifiers (i.e. there is
only a single heap allocated &#8220;<code class="docutils literal"><span class="pre">int</span></code>&#8221; type: &#8220;<code class="docutils literal"><span class="pre">const</span> <span class="pre">int</span></code>&#8221; and &#8220;<code class="docutils literal"><span class="pre">volatile</span>
<span class="pre">const</span> <span class="pre">int</span></code>&#8221; both point to the same heap allocated &#8220;<code class="docutils literal"><span class="pre">int</span></code>&#8221; type).  This
reduces the heap size used to represent bits and also means we do not have to
consider qualifiers when uniquing types (<a class="reference internal" href="#type"><span>Type</span></a> does not even
contain qualifiers).</p>
<p>In practice, the two most common type qualifiers (<code class="docutils literal"><span class="pre">const</span></code> and <code class="docutils literal"><span class="pre">restrict</span></code>)
are stored in the low bits of the pointer to the <code class="docutils literal"><span class="pre">Type</span></code> object, together with
a flag indicating whether extended qualifiers are present (which must be
heap-allocated).  This means that <code class="docutils literal"><span class="pre">QualType</span></code> is exactly the same size as a
pointer.</p>
</div>
<div class="section" id="declaration-names">
<span id="declarationname"></span><h3><a class="toc-backref" href="#id30">Declaration names</a><a class="headerlink" href="#declaration-names" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">DeclarationName</span></code> class represents the name of a declaration in Clang.
Declarations in the C family of languages can take several different forms.
Most declarations are named by simple identifiers, e.g., &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221; and &#8220;<code class="docutils literal"><span class="pre">x</span></code>&#8221; in
the function declaration <code class="docutils literal"><span class="pre">f(int</span> <span class="pre">x)</span></code>.  In C++, declaration names can also name
class constructors (&#8220;<code class="docutils literal"><span class="pre">Class</span></code>&#8221; in <code class="docutils literal"><span class="pre">struct</span> <span class="pre">Class</span> <span class="pre">{</span> <span class="pre">Class();</span> <span class="pre">}</span></code>), class
destructors (&#8220;<code class="docutils literal"><span class="pre">~Class</span></code>&#8221;), overloaded operator names (&#8220;<code class="docutils literal"><span class="pre">operator+</span></code>&#8221;), and
conversion functions (&#8220;<code class="docutils literal"><span class="pre">operator</span> <span class="pre">void</span> <span class="pre">const</span> <span class="pre">*</span></code>&#8221;).  In Objective-C,
declaration names can refer to the names of Objective-C methods, which involve
the method name and the parameters, collectively called a <em>selector</em>, e.g.,
&#8220;<code class="docutils literal"><span class="pre">setWidth:height:</span></code>&#8221;.  Since all of these kinds of entities &#8212; variables,
functions, Objective-C methods, C++ constructors, destructors, and operators
&#8212; are represented as subclasses of Clang&#8217;s common <code class="docutils literal"><span class="pre">NamedDecl</span></code> class,
<code class="docutils literal"><span class="pre">DeclarationName</span></code> is designed to efficiently represent any kind of name.</p>
<p>Given a <code class="docutils literal"><span class="pre">DeclarationName</span></code> <code class="docutils literal"><span class="pre">N</span></code>, <code class="docutils literal"><span class="pre">N.getNameKind()</span></code> will produce a value
that describes what kind of name <code class="docutils literal"><span class="pre">N</span></code> stores.  There are 10 options (all of
the names are inside the <code class="docutils literal"><span class="pre">DeclarationName</span></code> class).</p>
<p><code class="docutils literal"><span class="pre">Identifier</span></code></p>
<blockquote>
<div>The name is a simple identifier.  Use <code class="docutils literal"><span class="pre">N.getAsIdentifierInfo()</span></code> to retrieve
the corresponding <code class="docutils literal"><span class="pre">IdentifierInfo*</span></code> pointing to the actual identifier.</div></blockquote>
<p><code class="docutils literal"><span class="pre">ObjCZeroArgSelector</span></code>, <code class="docutils literal"><span class="pre">ObjCOneArgSelector</span></code>, <code class="docutils literal"><span class="pre">ObjCMultiArgSelector</span></code></p>
<blockquote>
<div>The name is an Objective-C selector, which can be retrieved as a <code class="docutils literal"><span class="pre">Selector</span></code>
instance via <code class="docutils literal"><span class="pre">N.getObjCSelector()</span></code>.  The three possible name kinds for
Objective-C reflect an optimization within the <code class="docutils literal"><span class="pre">DeclarationName</span></code> class:
both zero- and one-argument selectors are stored as a masked
<code class="docutils literal"><span class="pre">IdentifierInfo</span></code> pointer, and therefore require very little space, since
zero- and one-argument selectors are far more common than multi-argument
selectors (which use a different structure).</div></blockquote>
<p><code class="docutils literal"><span class="pre">CXXConstructorName</span></code></p>
<blockquote>
<div>The name is a C++ constructor name.  Use <code class="docutils literal"><span class="pre">N.getCXXNameType()</span></code> to retrieve
the <a class="reference internal" href="#qualtype"><span>type</span></a> that this constructor is meant to construct.  The
type is always the canonical type, since all constructors for a given type
have the same name.</div></blockquote>
<p><code class="docutils literal"><span class="pre">CXXDestructorName</span></code></p>
<blockquote>
<div>The name is a C++ destructor name.  Use <code class="docutils literal"><span class="pre">N.getCXXNameType()</span></code> to retrieve
the <a class="reference internal" href="#qualtype"><span>type</span></a> whose destructor is being named.  This type is
always a canonical type.</div></blockquote>
<p><code class="docutils literal"><span class="pre">CXXConversionFunctionName</span></code></p>
<blockquote>
<div>The name is a C++ conversion function.  Conversion functions are named
according to the type they convert to, e.g., &#8220;<code class="docutils literal"><span class="pre">operator</span> <span class="pre">void</span> <span class="pre">const</span> <span class="pre">*</span></code>&#8221;.
Use <code class="docutils literal"><span class="pre">N.getCXXNameType()</span></code> to retrieve the type that this conversion function
converts to.  This type is always a canonical type.</div></blockquote>
<p><code class="docutils literal"><span class="pre">CXXOperatorName</span></code></p>
<blockquote>
<div>The name is a C++ overloaded operator name.  Overloaded operators are named
according to their spelling, e.g., &#8220;<code class="docutils literal"><span class="pre">operator+</span></code>&#8221; or &#8220;<code class="docutils literal"><span class="pre">operator</span> <span class="pre">new</span> <span class="pre">[]</span></code>&#8221;.
Use <code class="docutils literal"><span class="pre">N.getCXXOverloadedOperator()</span></code> to retrieve the overloaded operator (a
value of type <code class="docutils literal"><span class="pre">OverloadedOperatorKind</span></code>).</div></blockquote>
<p><code class="docutils literal"><span class="pre">CXXLiteralOperatorName</span></code></p>
<blockquote>
<div>The name is a C++11 user defined literal operator.  User defined
Literal operators are named according to the suffix they define,
e.g., &#8220;<code class="docutils literal"><span class="pre">_foo</span></code>&#8221; for &#8220;<code class="docutils literal"><span class="pre">operator</span> <span class="pre">&quot;&quot;</span> <span class="pre">_foo</span></code>&#8221;.  Use
<code class="docutils literal"><span class="pre">N.getCXXLiteralIdentifier()</span></code> to retrieve the corresponding
<code class="docutils literal"><span class="pre">IdentifierInfo*</span></code> pointing to the identifier.</div></blockquote>
<p><code class="docutils literal"><span class="pre">CXXUsingDirective</span></code></p>
<blockquote>
<div>The name is a C++ using directive.  Using directives are not really
NamedDecls, in that they all have the same name, but they are
implemented as such in order to store them in DeclContext
effectively.</div></blockquote>
<p><code class="docutils literal"><span class="pre">DeclarationName</span></code>s are cheap to create, copy, and compare.  They require
only a single pointer&#8217;s worth of storage in the common cases (identifiers,
zero- and one-argument Objective-C selectors) and use dense, uniqued storage
for the other kinds of names.  Two <code class="docutils literal"><span class="pre">DeclarationName</span></code>s can be compared for
equality (<code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>) using a simple bitwise comparison, can be ordered
with <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, and <code class="docutils literal"><span class="pre">&gt;=</span></code> (which provide a lexicographical ordering
for normal identifiers but an unspecified ordering for other kinds of names),
and can be placed into LLVM <code class="docutils literal"><span class="pre">DenseMap</span></code>s and <code class="docutils literal"><span class="pre">DenseSet</span></code>s.</p>
<p><code class="docutils literal"><span class="pre">DeclarationName</span></code> instances can be created in different ways depending on
what kind of name the instance will store.  Normal identifiers
(<code class="docutils literal"><span class="pre">IdentifierInfo</span></code> pointers) and Objective-C selectors (<code class="docutils literal"><span class="pre">Selector</span></code>) can be
implicitly converted to <code class="docutils literal"><span class="pre">DeclarationNames</span></code>.  Names for C++ constructors,
destructors, conversion functions, and overloaded operators can be retrieved
from the <code class="docutils literal"><span class="pre">DeclarationNameTable</span></code>, an instance of which is available as
<code class="docutils literal"><span class="pre">ASTContext::DeclarationNames</span></code>.  The member functions
<code class="docutils literal"><span class="pre">getCXXConstructorName</span></code>, <code class="docutils literal"><span class="pre">getCXXDestructorName</span></code>,
<code class="docutils literal"><span class="pre">getCXXConversionFunctionName</span></code>, and <code class="docutils literal"><span class="pre">getCXXOperatorName</span></code>, respectively,
return <code class="docutils literal"><span class="pre">DeclarationName</span></code> instances for the four kinds of C++ special function
names.</p>
</div>
<div class="section" id="declaration-contexts">
<span id="declcontext"></span><h3><a class="toc-backref" href="#id31">Declaration contexts</a><a class="headerlink" href="#declaration-contexts" title="Permalink to this headline">¶</a></h3>
<p>Every declaration in a program exists within some <em>declaration context</em>, such
as a translation unit, namespace, class, or function.  Declaration contexts in
Clang are represented by the <code class="docutils literal"><span class="pre">DeclContext</span></code> class, from which the various
declaration-context AST nodes (<code class="docutils literal"><span class="pre">TranslationUnitDecl</span></code>, <code class="docutils literal"><span class="pre">NamespaceDecl</span></code>,
<code class="docutils literal"><span class="pre">RecordDecl</span></code>, <code class="docutils literal"><span class="pre">FunctionDecl</span></code>, etc.) will derive.  The <code class="docutils literal"><span class="pre">DeclContext</span></code> class
provides several facilities common to each declaration context:</p>
<p>Source-centric vs. Semantics-centric View of Declarations</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">DeclContext</span></code> provides two views of the declarations stored within a
declaration context.  The source-centric view accurately represents the
program source code as written, including multiple declarations of entities
where present (see the section <a class="reference internal" href="#redeclarations"><span>Redeclarations and Overloads</span></a>), while the semantics-centric view represents the program
semantics.  The two views are kept synchronized by semantic analysis while
the ASTs are being constructed.</div></blockquote>
<p>Storage of declarations within that context</p>
<blockquote>
<div>Every declaration context can contain some number of declarations.  For
example, a C++ class (represented by <code class="docutils literal"><span class="pre">RecordDecl</span></code>) contains various member
functions, fields, nested types, and so on.  All of these declarations will
be stored within the <code class="docutils literal"><span class="pre">DeclContext</span></code>, and one can iterate over the
declarations via [<code class="docutils literal"><span class="pre">DeclContext::decls_begin()</span></code>,
<code class="docutils literal"><span class="pre">DeclContext::decls_end()</span></code>).  This mechanism provides the source-centric
view of declarations in the context.</div></blockquote>
<p>Lookup of declarations within that context</p>
<blockquote>
<div>The <code class="docutils literal"><span class="pre">DeclContext</span></code> structure provides efficient name lookup for names within
that declaration context.  For example, if <code class="docutils literal"><span class="pre">N</span></code> is a namespace we can look
for the name <code class="docutils literal"><span class="pre">N::f</span></code> using <code class="docutils literal"><span class="pre">DeclContext::lookup</span></code>.  The lookup itself is
based on a lazily-constructed array (for declaration contexts with a small
number of declarations) or hash table (for declaration contexts with more
declarations).  The lookup operation provides the semantics-centric view of
the declarations in the context.</div></blockquote>
<p>Ownership of declarations</p>
<blockquote>
<div>The <code class="docutils literal"><span class="pre">DeclContext</span></code> owns all of the declarations that were declared within
its declaration context, and is responsible for the management of their
memory as well as their (de-)serialization.</div></blockquote>
<p>All declarations are stored within a declaration context, and one can query
information about the context in which each declaration lives.  One can
retrieve the <code class="docutils literal"><span class="pre">DeclContext</span></code> that contains a particular <code class="docutils literal"><span class="pre">Decl</span></code> using
<code class="docutils literal"><span class="pre">Decl::getDeclContext</span></code>.  However, see the section
<a class="reference internal" href="#lexicalandsemanticcontexts"><span>Lexical and Semantic Contexts</span></a> for more information about how to interpret
this context information.</p>
<div class="section" id="redeclarations-and-overloads">
<span id="redeclarations"></span><h4><a class="toc-backref" href="#id32">Redeclarations and Overloads</a><a class="headerlink" href="#redeclarations-and-overloads" title="Permalink to this headline">¶</a></h4>
<p>Within a translation unit, it is common for an entity to be declared several
times.  For example, we might declare a function &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221; and then later
re-declare it as part of an inlined definition:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ...  */</span> <span class="p">}</span>
</pre></div>
</div>
<p>The representation of &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221; differs in the source-centric and
semantics-centric views of a declaration context.  In the source-centric view,
all redeclarations will be present, in the order they occurred in the source
code, making this view suitable for clients that wish to see the structure of
the source code.  In the semantics-centric view, only the most recent &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221;
will be found by the lookup, since it effectively replaces the first
declaration of &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221;.</p>
<p>In the semantics-centric view, overloading of functions is represented
explicitly.  For example, given two declarations of a function &#8220;<code class="docutils literal"><span class="pre">g</span></code>&#8221; that are
overloaded, e.g.,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">g</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
<p>the <code class="docutils literal"><span class="pre">DeclContext::lookup</span></code> operation will return a
<code class="docutils literal"><span class="pre">DeclContext::lookup_result</span></code> that contains a range of iterators over
declarations of &#8220;<code class="docutils literal"><span class="pre">g</span></code>&#8221;.  Clients that perform semantic analysis on a program
that is not concerned with the actual source code will primarily use this
semantics-centric view.</p>
</div>
<div class="section" id="lexical-and-semantic-contexts">
<span id="lexicalandsemanticcontexts"></span><h4><a class="toc-backref" href="#id33">Lexical and Semantic Contexts</a><a class="headerlink" href="#lexical-and-semantic-contexts" title="Permalink to this headline">¶</a></h4>
<p>Each declaration has two potentially different declaration contexts: a
<em>lexical</em> context, which corresponds to the source-centric view of the
declaration context, and a <em>semantic</em> context, which corresponds to the
semantics-centric view.  The lexical context is accessible via
<code class="docutils literal"><span class="pre">Decl::getLexicalDeclContext</span></code> while the semantic context is accessible via
<code class="docutils literal"><span class="pre">Decl::getDeclContext</span></code>, both of which return <code class="docutils literal"><span class="pre">DeclContext</span></code> pointers.  For
most declarations, the two contexts are identical.  For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here, the semantic and lexical contexts of <code class="docutils literal"><span class="pre">X::f</span></code> are the <code class="docutils literal"><span class="pre">DeclContext</span></code>
associated with the class <code class="docutils literal"><span class="pre">X</span></code> (itself stored as a <code class="docutils literal"><span class="pre">RecordDecl</span></code> AST node).
However, we can now define <code class="docutils literal"><span class="pre">X::f</span></code> out-of-line:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">X</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">17</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ...  */</span> <span class="p">}</span>
</pre></div>
</div>
<p>This definition of &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221; has different lexical and semantic contexts.  The
lexical context corresponds to the declaration context in which the actual
declaration occurred in the source code, e.g., the translation unit containing
<code class="docutils literal"><span class="pre">X</span></code>.  Thus, this declaration of <code class="docutils literal"><span class="pre">X::f</span></code> can be found by traversing the
declarations provided by [<code class="docutils literal"><span class="pre">decls_begin()</span></code>, <code class="docutils literal"><span class="pre">decls_end()</span></code>) in the
translation unit.</p>
<p>The semantic context of <code class="docutils literal"><span class="pre">X::f</span></code> corresponds to the class <code class="docutils literal"><span class="pre">X</span></code>, since this
member function is (semantically) a member of <code class="docutils literal"><span class="pre">X</span></code>.  Lookup of the name <code class="docutils literal"><span class="pre">f</span></code>
into the <code class="docutils literal"><span class="pre">DeclContext</span></code> associated with <code class="docutils literal"><span class="pre">X</span></code> will then return the definition
of <code class="docutils literal"><span class="pre">X::f</span></code> (including information about the default argument).</p>
</div>
<div class="section" id="transparent-declaration-contexts">
<h4><a class="toc-backref" href="#id34">Transparent Declaration Contexts</a><a class="headerlink" href="#transparent-declaration-contexts" title="Permalink to this headline">¶</a></h4>
<p>In C and C++, there are several contexts in which names that are logically
declared inside another declaration will actually &#8220;leak&#8221; out into the enclosing
scope from the perspective of name lookup.  The most obvious instance of this
behavior is in enumeration types, e.g.,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span>
  <span class="n">Red</span><span class="p">,</span>
  <span class="n">Green</span><span class="p">,</span>
  <span class="n">Blue</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">Color</span></code> is an enumeration, which is a declaration context that contains
the enumerators <code class="docutils literal"><span class="pre">Red</span></code>, <code class="docutils literal"><span class="pre">Green</span></code>, and <code class="docutils literal"><span class="pre">Blue</span></code>.  Thus, traversing the list of
declarations contained in the enumeration <code class="docutils literal"><span class="pre">Color</span></code> will yield <code class="docutils literal"><span class="pre">Red</span></code>,
<code class="docutils literal"><span class="pre">Green</span></code>, and <code class="docutils literal"><span class="pre">Blue</span></code>.  However, outside of the scope of <code class="docutils literal"><span class="pre">Color</span></code> one can
name the enumerator <code class="docutils literal"><span class="pre">Red</span></code> without qualifying the name, e.g.,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Red</span><span class="p">;</span>
</pre></div>
</div>
<p>There are other entities in C++ that provide similar behavior.  For example,
linkage specifications that use curly braces:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// f and g are visible here</span>
</pre></div>
</div>
<p>For source-level accuracy, we treat the linkage specification and enumeration
type as a declaration context in which its enclosed declarations (&#8220;<code class="docutils literal"><span class="pre">Red</span></code>&#8221;,
&#8220;<code class="docutils literal"><span class="pre">Green</span></code>&#8221;, and &#8220;<code class="docutils literal"><span class="pre">Blue</span></code>&#8221;; &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221; and &#8220;<code class="docutils literal"><span class="pre">g</span></code>&#8221;) are declared.  However, these
declarations are visible outside of the scope of the declaration context.</p>
<p>These language features (and several others, described below) have roughly the
same set of requirements: declarations are declared within a particular lexical
context, but the declarations are also found via name lookup in scopes
enclosing the declaration itself.  This feature is implemented via
<em>transparent</em> declaration contexts (see
<code class="docutils literal"><span class="pre">DeclContext::isTransparentContext()</span></code>), whose declarations are visible in the
nearest enclosing non-transparent declaration context.  This means that the
lexical context of the declaration (e.g., an enumerator) will be the
transparent <code class="docutils literal"><span class="pre">DeclContext</span></code> itself, as will the semantic context, but the
declaration will be visible in every outer context up to and including the
first non-transparent declaration context (since transparent declaration
contexts can be nested).</p>
<p>The transparent <code class="docutils literal"><span class="pre">DeclContext</span></code>s are:</p>
<ul>
<li><p class="first">Enumerations (but not C++11 &#8220;scoped enumerations&#8221;):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span>
  <span class="n">Red</span><span class="p">,</span>
  <span class="n">Green</span><span class="p">,</span>
  <span class="n">Blue</span>
<span class="p">};</span>
<span class="c1">// Red, Green, and Blue are in scope</span>
</pre></div>
</div>
</li>
<li><p class="first">C++ linkage specifications:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// f and g are in scope</span>
</pre></div>
</div>
</li>
<li><p class="first">Anonymous unions and structs:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">LookupTable</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">IsVector</span><span class="p">;</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">Vector</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">Set</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="n">LookupTable</span> <span class="n">LT</span><span class="p">;</span>
<span class="n">LT</span><span class="p">.</span><span class="n">Vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Okay: finds Vector inside the unnamed union</span>
</pre></div>
</div>
</li>
<li><p class="first">C++11 inline namespaces:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">mylib</span> <span class="p">{</span>
  <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">debug</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">X</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">mylib</span><span class="o">::</span><span class="n">X</span> <span class="o">*</span><span class="n">xp</span><span class="p">;</span> <span class="c1">// okay: mylib::X refers to mylib::debug::X</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="multiply-defined-declaration-contexts">
<span id="multideclcontext"></span><h4><a class="toc-backref" href="#id35">Multiply-Defined Declaration Contexts</a><a class="headerlink" href="#multiply-defined-declaration-contexts" title="Permalink to this headline">¶</a></h4>
<p>C++ namespaces have the interesting &#8212; and, so far, unique &#8212; property that
the namespace can be defined multiple times, and the declarations provided by
each namespace definition are effectively merged (from the semantic point of
view).  For example, the following two code snippets are semantically
indistinguishable:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Snippet #1:</span>
<span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Snippet #2:</span>
<span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Clang&#8217;s representation, the source-centric view of declaration contexts will
actually have two separate <code class="docutils literal"><span class="pre">NamespaceDecl</span></code> nodes in Snippet #1, each of which
is a declaration context that contains a single declaration of &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221;.
However, the semantics-centric view provided by name lookup into the namespace
<code class="docutils literal"><span class="pre">N</span></code> for &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221; will return a <code class="docutils literal"><span class="pre">DeclContext::lookup_result</span></code> that contains a
range of iterators over declarations of &#8220;<code class="docutils literal"><span class="pre">f</span></code>&#8221;.</p>
<p><code class="docutils literal"><span class="pre">DeclContext</span></code> manages multiply-defined declaration contexts internally.  The
function <code class="docutils literal"><span class="pre">DeclContext::getPrimaryContext</span></code> retrieves the &#8220;primary&#8221; context for
a given <code class="docutils literal"><span class="pre">DeclContext</span></code> instance, which is the <code class="docutils literal"><span class="pre">DeclContext</span></code> responsible for
maintaining the lookup table used for the semantics-centric view.  Given a
DeclContext, one can obtain the set of declaration contexts that are semanticaly
connected to this declaration context, in source order, including this context
(which will be the only result, for non-namespace contexts) via
<code class="docutils literal"><span class="pre">DeclContext::collectAllContexts</span></code>. Note that these functions are used
internally within the lookup and insertion methods of the <code class="docutils literal"><span class="pre">DeclContext</span></code>, so
the vast majority of clients can ignore them.</p>
</div>
</div>
<div class="section" id="the-cfg-class">
<span id="cfg"></span><h3><a class="toc-backref" href="#id36">The <code class="docutils literal"><span class="pre">CFG</span></code> class</a><a class="headerlink" href="#the-cfg-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">CFG</span></code> class is designed to represent a source-level control-flow graph
for a single statement (<code class="docutils literal"><span class="pre">Stmt*</span></code>).  Typically instances of <code class="docutils literal"><span class="pre">CFG</span></code> are
constructed for function bodies (usually an instance of <code class="docutils literal"><span class="pre">CompoundStmt</span></code>), but
can also be instantiated to represent the control-flow of any class that
subclasses <code class="docutils literal"><span class="pre">Stmt</span></code>, which includes simple expressions.  Control-flow graphs
are especially useful for performing <a class="reference external" href="http://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities">flow- or path-sensitive</a> program
analyses on a given function.</p>
<div class="section" id="basic-blocks">
<h4><a class="toc-backref" href="#id37">Basic Blocks</a><a class="headerlink" href="#basic-blocks" title="Permalink to this headline">¶</a></h4>
<p>Concretely, an instance of <code class="docutils literal"><span class="pre">CFG</span></code> is a collection of basic blocks.  Each basic
block is an instance of <code class="docutils literal"><span class="pre">CFGBlock</span></code>, which simply contains an ordered sequence
of <code class="docutils literal"><span class="pre">Stmt*</span></code> (each referring to statements in the AST).  The ordering of
statements within a block indicates unconditional flow of control from one
statement to the next.  <a class="reference internal" href="#conditionalcontrolflow"><span>Conditional control-flow</span></a> is represented using edges between basic blocks.  The
statements within a given <code class="docutils literal"><span class="pre">CFGBlock</span></code> can be traversed using the
<code class="docutils literal"><span class="pre">CFGBlock::*iterator</span></code> interface.</p>
<p>A <code class="docutils literal"><span class="pre">CFG</span></code> object owns the instances of <code class="docutils literal"><span class="pre">CFGBlock</span></code> within the control-flow
graph it represents.  Each <code class="docutils literal"><span class="pre">CFGBlock</span></code> within a CFG is also uniquely numbered
(accessible via <code class="docutils literal"><span class="pre">CFGBlock::getBlockID()</span></code>).  Currently the number is based on
the ordering the blocks were created, but no assumptions should be made on how
<code class="docutils literal"><span class="pre">CFGBlocks</span></code> are numbered other than their numbers are unique and that they
are numbered from 0..N-1 (where N is the number of basic blocks in the CFG).</p>
</div>
<div class="section" id="entry-and-exit-blocks">
<h4><a class="toc-backref" href="#id38">Entry and Exit Blocks</a><a class="headerlink" href="#entry-and-exit-blocks" title="Permalink to this headline">¶</a></h4>
<p>Each instance of <code class="docutils literal"><span class="pre">CFG</span></code> contains two special blocks: an <em>entry</em> block
(accessible via <code class="docutils literal"><span class="pre">CFG::getEntry()</span></code>), which has no incoming edges, and an
<em>exit</em> block (accessible via <code class="docutils literal"><span class="pre">CFG::getExit()</span></code>), which has no outgoing edges.
Neither block contains any statements, and they serve the role of providing a
clear entrance and exit for a body of code such as a function body.  The
presence of these empty blocks greatly simplifies the implementation of many
analyses built on top of CFGs.</p>
</div>
<div class="section" id="conditional-control-flow">
<span id="conditionalcontrolflow"></span><h4><a class="toc-backref" href="#id39">Conditional Control-Flow</a><a class="headerlink" href="#conditional-control-flow" title="Permalink to this headline">¶</a></h4>
<p>Conditional control-flow (such as those induced by if-statements and loops) is
represented as edges between <code class="docutils literal"><span class="pre">CFGBlocks</span></code>.  Because different C language
constructs can induce control-flow, each <code class="docutils literal"><span class="pre">CFGBlock</span></code> also records an extra
<code class="docutils literal"><span class="pre">Stmt*</span></code> that represents the <em>terminator</em> of the block.  A terminator is
simply the statement that caused the control-flow, and is used to identify the
nature of the conditional control-flow between blocks.  For example, in the
case of an if-statement, the terminator refers to the <code class="docutils literal"><span class="pre">IfStmt</span></code> object in the
AST that represented the given branch.</p>
<p>To illustrate, consider the following code example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">x</span><span class="o">++</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After invoking the parser+semantic analyzer on this code fragment, the AST of
the body of <code class="docutils literal"><span class="pre">foo</span></code> is referenced by a single <code class="docutils literal"><span class="pre">Stmt*</span></code>.  We can then construct
an instance of <code class="docutils literal"><span class="pre">CFG</span></code> representing the control-flow graph of this function
body by single call to a static class method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Stmt</span> <span class="o">*</span><span class="n">FooBody</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CFG</span><span class="o">&gt;</span> <span class="n">FooCFG</span> <span class="o">=</span> <span class="n">CFG</span><span class="o">::</span><span class="n">buildCFG</span><span class="p">(</span><span class="n">FooBody</span><span class="p">);</span>
</pre></div>
</div>
<p>Along with providing an interface to iterate over its <code class="docutils literal"><span class="pre">CFGBlocks</span></code>, the
<code class="docutils literal"><span class="pre">CFG</span></code> class also provides methods that are useful for debugging and
visualizing CFGs.  For example, the method <code class="docutils literal"><span class="pre">CFG::dump()</span></code> dumps a
pretty-printed version of the CFG to standard error.  This is especially useful
when one is using a debugger such as gdb.  For example, here is the output of
<code class="docutils literal"><span class="pre">FooCFG-&gt;dump()</span></code>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">[</span> <span class="n">B5</span> <span class="p">(</span><span class="n">ENTRY</span><span class="p">)</span> <span class="p">]</span>
   <span class="n">Predecessors</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span>
   <span class="n">Successors</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span> <span class="n">B4</span>

<span class="p">[</span> <span class="n">B4</span> <span class="p">]</span>
   <span class="mi">1</span><span class="o">:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
   <span class="mi">2</span><span class="o">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
   <span class="nl">T</span><span class="p">:</span> <span class="k">if</span> <span class="p">[</span><span class="n">B4</span><span class="mf">.2</span><span class="p">]</span>
   <span class="n">Predecessors</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span> <span class="n">B5</span>
   <span class="n">Successors</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span> <span class="n">B3</span> <span class="n">B2</span>

<span class="p">[</span> <span class="n">B3</span> <span class="p">]</span>
   <span class="mi">1</span><span class="o">:</span> <span class="n">x</span><span class="o">++</span>
   <span class="n">Predecessors</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span> <span class="n">B4</span>
   <span class="n">Successors</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span> <span class="n">B1</span>

<span class="p">[</span> <span class="n">B2</span> <span class="p">]</span>
   <span class="mi">1</span><span class="o">:</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">2</span>
   <span class="mi">2</span><span class="o">:</span> <span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span>
   <span class="n">Predecessors</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span> <span class="n">B4</span>
   <span class="n">Successors</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span> <span class="n">B1</span>

<span class="p">[</span> <span class="n">B1</span> <span class="p">]</span>
   <span class="mi">1</span><span class="o">:</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
   <span class="n">Predecessors</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span> <span class="n">B2</span> <span class="n">B3</span>
   <span class="n">Successors</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span> <span class="n">B0</span>

<span class="p">[</span> <span class="n">B0</span> <span class="p">(</span><span class="n">EXIT</span><span class="p">)</span> <span class="p">]</span>
   <span class="n">Predecessors</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span> <span class="n">B1</span>
   <span class="n">Successors</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span>
</pre></div>
</div>
<p>For each block, the pretty-printed output displays for each block the number of
<em>predecessor</em> blocks (blocks that have outgoing control-flow to the given
block) and <em>successor</em> blocks (blocks that have control-flow that have incoming
control-flow from the given block).  We can also clearly see the special entry
and exit blocks at the beginning and end of the pretty-printed output.  For the
entry block (block B5), the number of predecessor blocks is 0, while for the
exit block (block B0) the number of successor blocks is 0.</p>
<p>The most interesting block here is B4, whose outgoing control-flow represents
the branching caused by the sole if-statement in <code class="docutils literal"><span class="pre">foo</span></code>.  Of particular
interest is the second statement in the block, <code class="docutils literal"><span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">2)</span></code>, and the terminator,
printed as <code class="docutils literal"><span class="pre">if</span> <span class="pre">[B4.2]</span></code>.  The second statement represents the evaluation of
the condition of the if-statement, which occurs before the actual branching of
control-flow.  Within the <code class="docutils literal"><span class="pre">CFGBlock</span></code> for B4, the <code class="docutils literal"><span class="pre">Stmt*</span></code> for the second
statement refers to the actual expression in the AST for <code class="docutils literal"><span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">2)</span></code>.  Thus
pointers to subclasses of <code class="docutils literal"><span class="pre">Expr</span></code> can appear in the list of statements in a
block, and not just subclasses of <code class="docutils literal"><span class="pre">Stmt</span></code> that refer to proper C statements.</p>
<p>The terminator of block B4 is a pointer to the <code class="docutils literal"><span class="pre">IfStmt</span></code> object in the AST.
The pretty-printer outputs <code class="docutils literal"><span class="pre">if</span> <span class="pre">[B4.2]</span></code> because the condition expression of
the if-statement has an actual place in the basic block, and thus the
terminator is essentially <em>referring</em> to the expression that is the second
statement of block B4 (i.e., B4.2).  In this manner, conditions for
control-flow (which also includes conditions for loops and switch statements)
are hoisted into the actual basic block.</p>
</div>
</div>
<div class="section" id="constant-folding-in-the-clang-ast">
<h3><a class="toc-backref" href="#id40">Constant Folding in the Clang AST</a><a class="headerlink" href="#constant-folding-in-the-clang-ast" title="Permalink to this headline">¶</a></h3>
<p>There are several places where constants and constant folding matter a lot to
the Clang front-end.  First, in general, we prefer the AST to retain the source
code as close to how the user wrote it as possible.  This means that if they
wrote &#8220;<code class="docutils literal"><span class="pre">5+4</span></code>&#8221;, we want to keep the addition and two constants in the AST, we
don&#8217;t want to fold to &#8220;<code class="docutils literal"><span class="pre">9</span></code>&#8221;.  This means that constant folding in various
ways turns into a tree walk that needs to handle the various cases.</p>
<p>However, there are places in both C and C++ that require constants to be
folded.  For example, the C standard defines what an &#8220;integer constant
expression&#8221; (i-c-e) is with very precise and specific requirements.  The
language then requires i-c-e&#8217;s in a lot of places (for example, the size of a
bitfield, the value for a case statement, etc).  For these, we have to be able
to constant fold the constants, to do semantic checks (e.g., verify bitfield
size is non-negative and that case statements aren&#8217;t duplicated).  We aim for
Clang to be very pedantic about this, diagnosing cases when the code does not
use an i-c-e where one is required, but accepting the code unless running with
<code class="docutils literal"><span class="pre">-pedantic-errors</span></code>.</p>
<p>Things get a little bit more tricky when it comes to compatibility with
real-world source code.  Specifically, GCC has historically accepted a huge
superset of expressions as i-c-e&#8217;s, and a lot of real world code depends on
this unfortuate accident of history (including, e.g., the glibc system
headers).  GCC accepts anything its &#8220;fold&#8221; optimizer is capable of reducing to
an integer constant, which means that the definition of what it accepts changes
as its optimizer does.  One example is that GCC accepts things like &#8220;<code class="docutils literal"><span class="pre">case</span>
<span class="pre">X-X:</span></code>&#8221; even when <code class="docutils literal"><span class="pre">X</span></code> is a variable, because it can fold this to 0.</p>
<p>Another issue are how constants interact with the extensions we support, such
as <code class="docutils literal"><span class="pre">__builtin_constant_p</span></code>, <code class="docutils literal"><span class="pre">__builtin_inf</span></code>, <code class="docutils literal"><span class="pre">__extension__</span></code> and many
others.  C99 obviously does not specify the semantics of any of these
extensions, and the definition of i-c-e does not include them.  However, these
extensions are often used in real code, and we have to have a way to reason
about them.</p>
<p>Finally, this is not just a problem for semantic analysis.  The code generator
and other clients have to be able to fold constants (e.g., to initialize global
variables) and has to handle a superset of what C99 allows.  Further, these
clients can benefit from extended information.  For example, we know that
&#8220;<code class="docutils literal"><span class="pre">foo()</span> <span class="pre">||</span> <span class="pre">1</span></code>&#8221; always evaluates to <code class="docutils literal"><span class="pre">true</span></code>, but we can&#8217;t replace the
expression with <code class="docutils literal"><span class="pre">true</span></code> because it has side effects.</p>
<div class="section" id="implementation-approach">
<h4><a class="toc-backref" href="#id41">Implementation Approach</a><a class="headerlink" href="#implementation-approach" title="Permalink to this headline">¶</a></h4>
<p>After trying several different approaches, we&#8217;ve finally converged on a design
(Note, at the time of this writing, not all of this has been implemented,
consider this a design goal!).  Our basic approach is to define a single
recursive method evaluation method (<code class="docutils literal"><span class="pre">Expr::Evaluate</span></code>), which is implemented
in <code class="docutils literal"><span class="pre">AST/ExprConstant.cpp</span></code>.  Given an expression with &#8220;scalar&#8221; type (integer,
fp, complex, or pointer) this method returns the following information:</p>
<ul class="simple">
<li>Whether the expression is an integer constant expression, a general constant
that was folded but has no side effects, a general constant that was folded
but that does have side effects, or an uncomputable/unfoldable value.</li>
<li>If the expression was computable in any way, this method returns the
<code class="docutils literal"><span class="pre">APValue</span></code> for the result of the expression.</li>
<li>If the expression is not evaluatable at all, this method returns information
on one of the problems with the expression.  This includes a
<code class="docutils literal"><span class="pre">SourceLocation</span></code> for where the problem is, and a diagnostic ID that explains
the problem.  The diagnostic should have <code class="docutils literal"><span class="pre">ERROR</span></code> type.</li>
<li>If the expression is not an integer constant expression, this method returns
information on one of the problems with the expression.  This includes a
<code class="docutils literal"><span class="pre">SourceLocation</span></code> for where the problem is, and a diagnostic ID that
explains the problem.  The diagnostic should have <code class="docutils literal"><span class="pre">EXTENSION</span></code> type.</li>
</ul>
<p>This information gives various clients the flexibility that they want, and we
will eventually have some helper methods for various extensions.  For example,
<code class="docutils literal"><span class="pre">Sema</span></code> should have a <code class="docutils literal"><span class="pre">Sema::VerifyIntegerConstantExpression</span></code> method, which
calls <code class="docutils literal"><span class="pre">Evaluate</span></code> on the expression.  If the expression is not foldable, the
error is emitted, and it would return <code class="docutils literal"><span class="pre">true</span></code>.  If the expression is not an
i-c-e, the <code class="docutils literal"><span class="pre">EXTENSION</span></code> diagnostic is emitted.  Finally it would return
<code class="docutils literal"><span class="pre">false</span></code> to indicate that the AST is OK.</p>
<p>Other clients can use the information in other ways, for example, codegen can
just use expressions that are foldable in any way.</p>
</div>
<div class="section" id="extensions">
<h4><a class="toc-backref" href="#id42">Extensions</a><a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a></h4>
<p>This section describes how some of the various extensions Clang supports
interacts with constant evaluation:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">__extension__</span></code>: The expression form of this extension causes any
evaluatable subexpression to be accepted as an integer constant expression.</li>
<li><code class="docutils literal"><span class="pre">__builtin_constant_p</span></code>: This returns true (as an integer constant
expression) if the operand evaluates to either a numeric value (that is, not
a pointer cast to integral type) of integral, enumeration, floating or
complex type, or if it evaluates to the address of the first character of a
string literal (possibly cast to some other type).  As a special case, if
<code class="docutils literal"><span class="pre">__builtin_constant_p</span></code> is the (potentially parenthesized) condition of a
conditional operator expression (&#8220;<code class="docutils literal"><span class="pre">?:</span></code>&#8221;), only the true side of the
conditional operator is considered, and it is evaluated with full constant
folding.</li>
<li><code class="docutils literal"><span class="pre">__builtin_choose_expr</span></code>: The condition is required to be an integer
constant expression, but we accept any constant as an &#8220;extension of an
extension&#8221;.  This only evaluates one operand depending on which way the
condition evaluates.</li>
<li><code class="docutils literal"><span class="pre">__builtin_classify_type</span></code>: This always returns an integer constant
expression.</li>
<li><code class="docutils literal"><span class="pre">__builtin_inf,</span> <span class="pre">nan,</span> <span class="pre">...</span></code>: These are treated just like a floating-point
literal.</li>
<li><code class="docutils literal"><span class="pre">__builtin_abs,</span> <span class="pre">copysign,</span> <span class="pre">...</span></code>: These are constant folded as general
constant expressions.</li>
<li><code class="docutils literal"><span class="pre">__builtin_strlen</span></code> and <code class="docutils literal"><span class="pre">strlen</span></code>: These are constant folded as integer
constant expressions if the argument is a string literal.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="the-sema-library">
<span id="sema"></span><h2><a class="toc-backref" href="#id43">The Sema Library</a><a class="headerlink" href="#the-sema-library" title="Permalink to this headline">¶</a></h2>
<p>This library is called by the <a class="reference internal" href="#parser"><span>Parser library</span></a> during parsing to
do semantic analysis of the input.  For valid programs, Sema builds an AST for
parsed constructs.</p>
</div>
<div class="section" id="the-codegen-library">
<span id="codegen"></span><h2><a class="toc-backref" href="#id44">The CodeGen Library</a><a class="headerlink" href="#the-codegen-library" title="Permalink to this headline">¶</a></h2>
<p>CodeGen takes an <a class="reference internal" href="#ast"><span>AST</span></a> as input and produces <a class="reference external" href="//llvm.org/docs/LangRef.html">LLVM IR code</a> from it.</p>
</div>
<div class="section" id="how-to-change-clang">
<h2><a class="toc-backref" href="#id45">How to change Clang</a><a class="headerlink" href="#how-to-change-clang" title="Permalink to this headline">¶</a></h2>
<div class="section" id="how-to-add-an-attribute">
<h3><a class="toc-backref" href="#id46">How to add an attribute</a><a class="headerlink" href="#how-to-add-an-attribute" title="Permalink to this headline">¶</a></h3>
<p>Attributes are a form of metadata that can be attached to a program construct,
allowing the programmer to pass semantic information along to the compiler for
various uses. For example, attributes may be used to alter the code generation
for a program construct, or to provide extra semantic information for static
analysis. This document explains how to add a custom attribute to Clang.
Documentation on existing attributes can be found <a class="reference external" href="//clang.llvm.org/docs/AttributeReference.html">here</a>.</p>
<div class="section" id="attribute-basics">
<h4><a class="toc-backref" href="#id47">Attribute Basics</a><a class="headerlink" href="#attribute-basics" title="Permalink to this headline">¶</a></h4>
<p>Attributes in Clang are handled in three stages: parsing into a parsed attribute
representation, conversion from a parsed attribute into a semantic attribute,
and then the semantic handling of the attribute.</p>
<p>Parsing of the attribute is determined by the various syntactic forms attributes
can take, such as GNU, C++11, and Microsoft style attributes, as well as other
information provided by the table definition of the attribute. Ultimately, the
parsed representation of an attribute object is an <code class="docutils literal"><span class="pre">AttributeList</span></code> object.
These parsed attributes chain together as a list of parsed attributes attached
to a declarator or declaration specifier. The parsing of attributes is handled
automatically by Clang, except for attributes spelled as keywords. When
implementing a keyword attribute, the parsing of the keyword and creation of the
<code class="docutils literal"><span class="pre">AttributeList</span></code> object must be done manually.</p>
<p>Eventually, <code class="docutils literal"><span class="pre">Sema::ProcessDeclAttributeList()</span></code> is called with a <code class="docutils literal"><span class="pre">Decl</span></code> and
an <code class="docutils literal"><span class="pre">AttributeList</span></code>, at which point the parsed attribute can be transformed
into a semantic attribute. The process by which a parsed attribute is converted
into a semantic attribute depends on the attribute definition and semantic
requirements of the attribute. The end result, however, is that the semantic
attribute object is attached to the <code class="docutils literal"><span class="pre">Decl</span></code> object, and can be obtained by a
call to <code class="docutils literal"><span class="pre">Decl::getAttr&lt;T&gt;()</span></code>.</p>
<p>The structure of the semantic attribute is also governed by the attribute
definition given in Attr.td. This definition is used to automatically generate
functionality used for the implementation of the attribute, such as a class
derived from <code class="docutils literal"><span class="pre">clang::Attr</span></code>, information for the parser to use, automated
semantic checking for some attributes, etc.</p>
</div>
<div class="section" id="include-clang-basic-attr-td">
<h4><a class="toc-backref" href="#id48"><code class="docutils literal"><span class="pre">include/clang/Basic/Attr.td</span></code></a><a class="headerlink" href="#include-clang-basic-attr-td" title="Permalink to this headline">¶</a></h4>
<p>The first step to adding a new attribute to Clang is to add its definition to
<a class="reference external" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/Attr.td?view=markup">include/clang/Basic/Attr.td</a>.
This tablegen definition must derive from the <code class="docutils literal"><span class="pre">Attr</span></code> (tablegen, not
semantic) type, or one of its derivatives. Most attributes will derive from the
<code class="docutils literal"><span class="pre">InheritableAttr</span></code> type, which specifies that the attribute can be inherited by
later redeclarations of the <code class="docutils literal"><span class="pre">Decl</span></code> it is associated with.
<code class="docutils literal"><span class="pre">InheritableParamAttr</span></code> is similar to <code class="docutils literal"><span class="pre">InheritableAttr</span></code>, except that the
attribute is written on a parameter instead of a declaration. If the attribute
is intended to apply to a type instead of a declaration, such an attribute
should derive from <code class="docutils literal"><span class="pre">TypeAttr</span></code>, and will generally not be given an AST
representation. (Note that this document does not cover the creation of type
attributes.) An attribute that inherits from <code class="docutils literal"><span class="pre">IgnoredAttr</span></code> is parsed, but will
generate an ignored attribute diagnostic when used, which may be useful when an
attribute is supported by another vendor but not supported by clang.</p>
<p>The definition will specify several key pieces of information, such as the
semantic name of the attribute, the spellings the attribute supports, the
arguments the attribute expects, and more. Most members of the <code class="docutils literal"><span class="pre">Attr</span></code> tablegen
type do not require definitions in the derived definition as the default
suffice. However, every attribute must specify at least a spelling list, a
subject list, and a documentation list.</p>
<div class="section" id="spellings">
<h5><a class="toc-backref" href="#id49">Spellings</a><a class="headerlink" href="#spellings" title="Permalink to this headline">¶</a></h5>
<p>All attributes are required to specify a spelling list that denotes the ways in
which the attribute can be spelled. For instance, a single semantic attribute
may have a keyword spelling, as well as a C++11 spelling and a GNU spelling. An
empty spelling list is also permissible and may be useful for attributes which
are created implicitly. The following spellings are accepted:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Spelling</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">GNU</span></code></td>
<td>Spelled with a GNU-style <code class="docutils literal"><span class="pre">__attribute__((attr))</span></code> syntax and
placement.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CXX11</span></code></td>
<td>Spelled with a C++-style <code class="docutils literal"><span class="pre">[[attr]]</span></code> syntax. If the attribute
is meant to be used by Clang, it should set the namespace to
<code class="docutils literal"><span class="pre">&quot;clang&quot;</span></code>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">Declspec</span></code></td>
<td>Spelled with a Microsoft-style <code class="docutils literal"><span class="pre">__declspec(attr)</span></code> syntax.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">Keyword</span></code></td>
<td>The attribute is spelled as a keyword, and required custom
parsing.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">GCC</span></code></td>
<td>Specifies two spellings: the first is a GNU-style spelling, and
the second is a C++-style spelling with the <code class="docutils literal"><span class="pre">gnu</span></code> namespace.
Attributes should only specify this spelling for attributes
supported by GCC.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">Pragma</span></code></td>
<td>The attribute is spelled as a <code class="docutils literal"><span class="pre">#pragma</span></code>, and requires custom
processing within the preprocessor. If the attribute is meant to
be used by Clang, it should set the namespace to <code class="docutils literal"><span class="pre">&quot;clang&quot;</span></code>.
Note that this spelling is not used for declaration attributes.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="subjects">
<h5><a class="toc-backref" href="#id50">Subjects</a><a class="headerlink" href="#subjects" title="Permalink to this headline">¶</a></h5>
<p>Attributes appertain to one or more <code class="docutils literal"><span class="pre">Decl</span></code> subjects. If the attribute attempts
to attach to a subject that is not in the subject list, a diagnostic is issued
automatically. Whether the diagnostic is a warning or an error depends on how
the attribute&#8217;s <code class="docutils literal"><span class="pre">SubjectList</span></code> is defined, but the default behavior is to warn.
The diagnostics displayed to the user are automatically determined based on the
subjects in the list, but a custom diagnostic parameter can also be specified in
the <code class="docutils literal"><span class="pre">SubjectList</span></code>. The diagnostics generated for subject list violations are
either <code class="docutils literal"><span class="pre">diag::warn_attribute_wrong_decl_type</span></code> or
<code class="docutils literal"><span class="pre">diag::err_attribute_wrong_decl_type</span></code>, and the parameter enumeration is found
in <a class="reference external" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Sema/AttributeList.h?view=markup">include/clang/Sema/AttributeList.h</a>
If a previously unused Decl node is added to the <code class="docutils literal"><span class="pre">SubjectList</span></code>, the logic used
to automatically determine the diagnostic parameter in <a class="reference external" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup">utils/TableGen/ClangAttrEmitter.cpp</a>
may need to be updated.</p>
<p>By default, all subjects in the SubjectList must either be a Decl node defined
in <code class="docutils literal"><span class="pre">DeclNodes.td</span></code>, or a statement node defined in <code class="docutils literal"><span class="pre">StmtNodes.td</span></code>. However,
more complex subjects can be created by creating a <code class="docutils literal"><span class="pre">SubsetSubject</span></code> object.
Each such object has a base subject which it appertains to (which must be a
Decl or Stmt node, and not a SubsetSubject node), and some custom code which is
called when determining whether an attribute appertains to the subject. For
instance, a <code class="docutils literal"><span class="pre">NonBitField</span></code> SubsetSubject appertains to a <code class="docutils literal"><span class="pre">FieldDecl</span></code>, and
tests whether the given FieldDecl is a bit field. When a SubsetSubject is
specified in a SubjectList, a custom diagnostic parameter must also be provided.</p>
<p>Diagnostic checking for attribute subject lists is automated except when
<code class="docutils literal"><span class="pre">HasCustomParsing</span></code> is set to <code class="docutils literal"><span class="pre">1</span></code>.</p>
</div>
<div class="section" id="documentation">
<h5><a class="toc-backref" href="#id51">Documentation</a><a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h5>
<p>All attributes must have some form of documentation associated with them.
Documentation is table generated on the public web server by a server-side
process that runs daily. Generally, the documentation for an attribute is a
stand-alone definition in <a class="reference external" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/AttdDocs.td?view=markup">include/clang/Basic/AttrDocs.td</a>
that is named after the attribute being documented.</p>
<p>If the attribute is not for public consumption, or is an implicitly-created
attribute that has no visible spelling, the documentation list can specify the
<code class="docutils literal"><span class="pre">Undocumented</span></code> object. Otherwise, the attribute should have its documentation
added to AttrDocs.td.</p>
<p>Documentation derives from the <code class="docutils literal"><span class="pre">Documentation</span></code> tablegen type. All derived
types must specify a documentation category and the actual documentation itself.
Additionally, it can specify a custom heading for the attribute, though a
default heading will be chosen when possible.</p>
<p>There are four predefined documentation categories: <code class="docutils literal"><span class="pre">DocCatFunction</span></code> for
attributes that appertain to function-like subjects, <code class="docutils literal"><span class="pre">DocCatVariable</span></code> for
attributes that appertain to variable-like subjects, <code class="docutils literal"><span class="pre">DocCatType</span></code> for type
attributes, and <code class="docutils literal"><span class="pre">DocCatStmt</span></code> for statement attributes. A custom documentation
category should be used for groups of attributes with similar functionality.
Custom categories are good for providing overview information for the attributes
grouped under it. For instance, the consumed annotation attributes define a
custom category, <code class="docutils literal"><span class="pre">DocCatConsumed</span></code>, that explains what consumed annotations are
at a high level.</p>
<p>Documentation content (whether it is for an attribute or a category) is written
using reStructuredText (RST) syntax.</p>
<p>After writing the documentation for the attribute, it should be locally tested
to ensure that there are no issues generating the documentation on the server.
Local testing requires a fresh build of clang-tblgen. To generate the attribute
documentation, execute the following command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">clang</span><span class="o">-</span><span class="n">tblgen</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">attr</span><span class="o">-</span><span class="n">docs</span> <span class="o">-</span><span class="n">I</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">include</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">Basic</span><span class="o">/</span><span class="n">Attr</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span><span class="n">o</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">docs</span><span class="o">/</span><span class="n">AttributeReference</span><span class="o">.</span><span class="n">rst</span>
</pre></div>
</div>
<p>When testing locally, <em>do not</em> commit changes to <code class="docutils literal"><span class="pre">AttributeReference.rst</span></code>.
This file is generated by the server automatically, and any changes made to this
file will be overwritten.</p>
</div>
<div class="section" id="arguments">
<h5><a class="toc-backref" href="#id52">Arguments</a><a class="headerlink" href="#arguments" title="Permalink to this headline">¶</a></h5>
<p>Attributes may optionally specify a list of arguments that can be passed to the
attribute. Attribute arguments specify both the parsed form and the semantic
form of the attribute. For example, if <code class="docutils literal"><span class="pre">Args</span></code> is
<code class="docutils literal"><span class="pre">[StringArgument&lt;&quot;Arg1&quot;&gt;,</span> <span class="pre">IntArgument&lt;&quot;Arg2&quot;&gt;]</span></code> then
<code class="docutils literal"><span class="pre">__attribute__((myattribute(&quot;Hello&quot;,</span> <span class="pre">3)))</span></code> will be a valid use; it requires
two arguments while parsing, and the Attr subclass&#8217; constructor for the
semantic attribute will require a string and integer argument.</p>
<p>All arguments have a name and a flag that specifies whether the argument is
optional. The associated C++ type of the argument is determined by the argument
definition type. If the existing argument types are insufficient, new types can
be created, but it requires modifying <a class="reference external" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/utils/TableGen/ClangAttrEmitter.cpp?view=markup">utils/TableGen/ClangAttrEmitter.cpp</a>
to properly support the type.</p>
</div>
<div class="section" id="other-properties">
<h5><a class="toc-backref" href="#id53">Other Properties</a><a class="headerlink" href="#other-properties" title="Permalink to this headline">¶</a></h5>
<p>The <code class="docutils literal"><span class="pre">Attr</span></code> definition has other members which control the behavior of the
attribute. Many of them are special-purpose and beyond the scope of this
document, however a few deserve mention.</p>
<p>If the parsed form of the attribute is more complex, or differs from the
semantic form, the <code class="docutils literal"><span class="pre">HasCustomParsing</span></code> bit can be set to <code class="docutils literal"><span class="pre">1</span></code> for the class,
and the parsing code in <a class="reference external" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseDecl.cpp?view=markup">Parser::ParseGNUAttributeArgs()</a>
can be updated for the special case. Note that this only applies to arguments
with a GNU spelling &#8211; attributes with a __declspec spelling currently ignore
this flag and are handled by <code class="docutils literal"><span class="pre">Parser::ParseMicrosoftDeclSpec</span></code>.</p>
<p>Note that setting this member to 1 will opt out of common attribute semantic
handling, requiring extra implementation efforts to ensure the attribute
appertains to the appropriate subject, etc.</p>
<p>If the attribute should not be propagated from from a template declaration to an
instantiation of the template, set the <code class="docutils literal"><span class="pre">Clone</span></code> member to 0. By default, all
attributes will be cloned to template instantiations.</p>
<p>Attributes that do not require an AST node should set the <code class="docutils literal"><span class="pre">ASTNode</span></code> field to
<code class="docutils literal"><span class="pre">0</span></code> to avoid polluting the AST. Note that anything inheriting from
<code class="docutils literal"><span class="pre">TypeAttr</span></code> or <code class="docutils literal"><span class="pre">IgnoredAttr</span></code> automatically do not generate an AST node. All
other attributes generate an AST node by default. The AST node is the semantic
representation of the attribute.</p>
<p>The <code class="docutils literal"><span class="pre">LangOpts</span></code> field specifies a list of language options required by the
attribute.  For instance, all of the CUDA-specific attributes specify <code class="docutils literal"><span class="pre">[CUDA]</span></code>
for the <code class="docutils literal"><span class="pre">LangOpts</span></code> field, and when the CUDA language option is not enabled, an
&#8220;attribute ignored&#8221; warning diagnostic is emitted. Since language options are
not table generated nodes, new language options must be created manually and
should specify the spelling used by <code class="docutils literal"><span class="pre">LangOptions</span></code> class.</p>
<p>Custom accessors can be generated for an attribute based on the spelling list
for that attribute. For instance, if an attribute has two different spellings:
&#8216;Foo&#8217; and &#8216;Bar&#8217;, accessors can be created:
<code class="docutils literal"><span class="pre">[Accessor&lt;&quot;isFoo&quot;,</span> <span class="pre">[GNU&lt;&quot;Foo&quot;&gt;]&gt;,</span> <span class="pre">Accessor&lt;&quot;isBar&quot;,</span> <span class="pre">[GNU&lt;&quot;Bar&quot;&gt;]&gt;]</span></code>
These accessors will be generated on the semantic form of the attribute,
accepting no arguments and returning a <code class="docutils literal"><span class="pre">bool</span></code>.</p>
<p>Attributes that do not require custom semantic handling should set the
<code class="docutils literal"><span class="pre">SemaHandler</span></code> field to <code class="docutils literal"><span class="pre">0</span></code>. Note that anything inheriting from
<code class="docutils literal"><span class="pre">IgnoredAttr</span></code> automatically do not get a semantic handler. All other
attributes are assumed to use a semantic handler by default. Attributes
without a semantic handler are not given a parsed attribute <code class="docutils literal"><span class="pre">Kind</span></code> enumerator.</p>
<p>Target-specific attributes may share a spelling with other attributes in
different targets. For instance, the ARM and MSP430 targets both have an
attribute spelled <code class="docutils literal"><span class="pre">GNU&lt;&quot;interrupt&quot;&gt;</span></code>, but with different parsing and semantic
requirements. To support this feature, an attribute inheriting from
<code class="docutils literal"><span class="pre">TargetSpecificAttribute</span></code> may specify a <code class="docutils literal"><span class="pre">ParseKind</span></code> field. This field
should be the same value between all arguments sharing a spelling, and
corresponds to the parsed attribute&#8217;s <code class="docutils literal"><span class="pre">Kind</span></code> enumerator. This allows
attributes to share a parsed attribute kind, but have distinct semantic
attribute classes. For instance, <code class="docutils literal"><span class="pre">AttributeList::AT_Interrupt</span></code> is the shared
parsed attribute kind, but ARMInterruptAttr and MSP430InterruptAttr are the
semantic attributes generated.</p>
<p>By default, when declarations are merging attributes, an attribute will not be
duplicated. However, if an attribute can be duplicated during this merging
stage, set <code class="docutils literal"><span class="pre">DuplicatesAllowedWhileMerging</span></code> to <code class="docutils literal"><span class="pre">1</span></code>, and the attribute will
be merged.</p>
<p>By default, attribute arguments are parsed in an evaluated context. If the
arguments for an attribute should be parsed in an unevaluated context (akin to
the way the argument to a <code class="docutils literal"><span class="pre">sizeof</span></code> expression is parsed), set
<code class="docutils literal"><span class="pre">ParseArgumentsAsUnevaluated</span></code> to <code class="docutils literal"><span class="pre">1</span></code>.</p>
<p>If additional functionality is desired for the semantic form of the attribute,
the <code class="docutils literal"><span class="pre">AdditionalMembers</span></code> field specifies code to be copied verbatim into the
semantic attribute class object, with <code class="docutils literal"><span class="pre">public</span></code> access.</p>
</div>
</div>
<div class="section" id="boilerplate">
<h4><a class="toc-backref" href="#id54">Boilerplate</a><a class="headerlink" href="#boilerplate" title="Permalink to this headline">¶</a></h4>
<p>All semantic processing of declaration attributes happens in <a class="reference external" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Sema/SemaDeclAttr.cpp?view=markup">lib/Sema/SemaDeclAttr.cpp</a>,
and generally starts in the <code class="docutils literal"><span class="pre">ProcessDeclAttribute()</span></code> function. If the
attribute is a &#8220;simple&#8221; attribute &#8211; meaning that it requires no custom semantic
processing aside from what is automatically  provided, add a call to
<code class="docutils literal"><span class="pre">handleSimpleAttribute&lt;YourAttr&gt;(S,</span> <span class="pre">D,</span> <span class="pre">Attr);</span></code> to the switch statement.
Otherwise, write a new <code class="docutils literal"><span class="pre">handleYourAttr()</span></code> function, and add that to the switch
statement. Please do not implement handling logic directly in the <code class="docutils literal"><span class="pre">case</span></code> for
the attribute.</p>
<p>Unless otherwise specified by the attribute definition, common semantic checking
of the parsed attribute is handled automatically. This includes diagnosing
parsed attributes that do not appertain to the given <code class="docutils literal"><span class="pre">Decl</span></code>, ensuring the
correct minimum number of arguments are passed, etc.</p>
<p>If the attribute adds additional warnings, define a <code class="docutils literal"><span class="pre">DiagGroup</span></code> in
<a class="reference external" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticGroups.td?view=markup">include/clang/Basic/DiagnosticGroups.td</a>
named after the attribute&#8217;s <code class="docutils literal"><span class="pre">Spelling</span></code> with &#8220;_&#8221;s replaced by &#8220;-&#8220;s. If there
is only a single diagnostic, it is permissible to use <code class="docutils literal"><span class="pre">InGroup&lt;DiagGroup&lt;&quot;your-attribute&quot;&gt;&gt;</span></code>
directly in <a class="reference external" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/include/clang/Basic/DiagnosticSemaKinds.td?view=markup">DiagnosticSemaKinds.td</a></p>
<p>All semantic diagnostics generated for your attribute, including automatically-
generated ones (such as subjects and argument counts), should have a
corresponding test case.</p>
</div>
<div class="section" id="semantic-handling">
<h4><a class="toc-backref" href="#id55">Semantic handling</a><a class="headerlink" href="#semantic-handling" title="Permalink to this headline">¶</a></h4>
<p>Most attributes are implemented to have some effect on the compiler. For
instance, to modify the way code is generated, or to add extra semantic checks
for an analysis pass, etc. Having added the attribute definition and conversion
to the semantic representation for the attribute, what remains is to implement
the custom logic requiring use of the attribute.</p>
<p>The <code class="docutils literal"><span class="pre">clang::Decl</span></code> object can be queried for the presence or absence of an
attribute using <code class="docutils literal"><span class="pre">hasAttr&lt;T&gt;()</span></code>. To obtain a pointer to the semantic
representation of the attribute, <code class="docutils literal"><span class="pre">getAttr&lt;T&gt;</span></code> may be used.</p>
</div>
</div>
<div class="section" id="how-to-add-an-expression-or-statement">
<h3><a class="toc-backref" href="#id56">How to add an expression or statement</a><a class="headerlink" href="#how-to-add-an-expression-or-statement" title="Permalink to this headline">¶</a></h3>
<p>Expressions and statements are one of the most fundamental constructs within a
compiler, because they interact with many different parts of the AST, semantic
analysis, and IR generation.  Therefore, adding a new expression or statement
kind into Clang requires some care.  The following list details the various
places in Clang where an expression or statement needs to be introduced, along
with patterns to follow to ensure that the new expression or statement works
well across all of the C languages.  We focus on expressions, but statements
are similar.</p>
<ol class="arabic simple">
<li>Introduce parsing actions into the parser.  Recursive-descent parsing is
mostly self-explanatory, but there are a few things that are worth keeping
in mind:<ul>
<li>Keep as much source location information as possible! You&#8217;ll want it later
to produce great diagnostics and support Clang&#8217;s various features that map
between source code and the AST.</li>
<li>Write tests for all of the &#8220;bad&#8221; parsing cases, to make sure your recovery
is good.  If you have matched delimiters (e.g., parentheses, square
brackets, etc.), use <code class="docutils literal"><span class="pre">Parser::BalancedDelimiterTracker</span></code> to give nice
diagnostics when things go wrong.</li>
</ul>
</li>
<li>Introduce semantic analysis actions into <code class="docutils literal"><span class="pre">Sema</span></code>.  Semantic analysis should
always involve two functions: an <code class="docutils literal"><span class="pre">ActOnXXX</span></code> function that will be called
directly from the parser, and a <code class="docutils literal"><span class="pre">BuildXXX</span></code> function that performs the
actual semantic analysis and will (eventually!) build the AST node.  It&#8217;s
fairly common for the <code class="docutils literal"><span class="pre">ActOnCXX</span></code> function to do very little (often just
some minor translation from the parser&#8217;s representation to <code class="docutils literal"><span class="pre">Sema</span></code>&#8216;s
representation of the same thing), but the separation is still important:
C++ template instantiation, for example, should always call the <code class="docutils literal"><span class="pre">BuildXXX</span></code>
variant.  Several notes on semantic analysis before we get into construction
of the AST:<ul>
<li>Your expression probably involves some types and some subexpressions.
Make sure to fully check that those types, and the types of those
subexpressions, meet your expectations.  Add implicit conversions where
necessary to make sure that all of the types line up exactly the way you
want them.  Write extensive tests to check that you&#8217;re getting good
diagnostics for mistakes and that you can use various forms of
subexpressions with your expression.</li>
<li>When type-checking a type or subexpression, make sure to first check
whether the type is &#8220;dependent&#8221; (<code class="docutils literal"><span class="pre">Type::isDependentType()</span></code>) or whether a
subexpression is type-dependent (<code class="docutils literal"><span class="pre">Expr::isTypeDependent()</span></code>).  If any of
these return <code class="docutils literal"><span class="pre">true</span></code>, then you&#8217;re inside a template and you can&#8217;t do much
type-checking now.  That&#8217;s normal, and your AST node (when you get there)
will have to deal with this case.  At this point, you can write tests that
use your expression within templates, but don&#8217;t try to instantiate the
templates.</li>
<li>For each subexpression, be sure to call <code class="docutils literal"><span class="pre">Sema::CheckPlaceholderExpr()</span></code>
to deal with &#8220;weird&#8221; expressions that don&#8217;t behave well as subexpressions.
Then, determine whether you need to perform lvalue-to-rvalue conversions
(<code class="docutils literal"><span class="pre">Sema::DefaultLvalueConversions</span></code>) or the usual unary conversions
(<code class="docutils literal"><span class="pre">Sema::UsualUnaryConversions</span></code>), for places where the subexpression is
producing a value you intend to use.</li>
<li>Your <code class="docutils literal"><span class="pre">BuildXXX</span></code> function will probably just return <code class="docutils literal"><span class="pre">ExprError()</span></code> at
this point, since you don&#8217;t have an AST.  That&#8217;s perfectly fine, and
shouldn&#8217;t impact your testing.</li>
</ul>
</li>
<li>Introduce an AST node for your new expression.  This starts with declaring
the node in <code class="docutils literal"><span class="pre">include/Basic/StmtNodes.td</span></code> and creating a new class for your
expression in the appropriate <code class="docutils literal"><span class="pre">include/AST/Expr*.h</span></code> header.  It&#8217;s best to
look at the class for a similar expression to get ideas, and there are some
specific things to watch for:<ul>
<li>If you need to allocate memory, use the <code class="docutils literal"><span class="pre">ASTContext</span></code> allocator to
allocate memory.  Never use raw <code class="docutils literal"><span class="pre">malloc</span></code> or <code class="docutils literal"><span class="pre">new</span></code>, and never hold any
resources in an AST node, because the destructor of an AST node is never
called.</li>
<li>Make sure that <code class="docutils literal"><span class="pre">getSourceRange()</span></code> covers the exact source range of your
expression.  This is needed for diagnostics and for IDE support.</li>
<li>Make sure that <code class="docutils literal"><span class="pre">children()</span></code> visits all of the subexpressions.  This is
important for a number of features (e.g., IDE support, C++ variadic
templates).  If you have sub-types, you&#8217;ll also need to visit those
sub-types in <code class="docutils literal"><span class="pre">RecursiveASTVisitor</span></code> and <code class="docutils literal"><span class="pre">DataRecursiveASTVisitor</span></code>.</li>
<li>Add printing support (<code class="docutils literal"><span class="pre">StmtPrinter.cpp</span></code>) for your expression.</li>
<li>Add profiling support (<code class="docutils literal"><span class="pre">StmtProfile.cpp</span></code>) for your AST node, noting the
distinguishing (non-source location) characteristics of an instance of
your expression.  Omitting this step will lead to hard-to-diagnose
failures regarding matching of template declarations.</li>
<li>Add serialization support (<code class="docutils literal"><span class="pre">ASTReaderStmt.cpp</span></code>, <code class="docutils literal"><span class="pre">ASTWriterStmt.cpp</span></code>)
for your AST node.</li>
</ul>
</li>
<li>Teach semantic analysis to build your AST node.  At this point, you can wire
up your <code class="docutils literal"><span class="pre">Sema::BuildXXX</span></code> function to actually create your AST.  A few
things to check at this point:<ul>
<li>If your expression can construct a new C++ class or return a new
Objective-C object, be sure to update and then call
<code class="docutils literal"><span class="pre">Sema::MaybeBindToTemporary</span></code> for your just-created AST node to be sure
that the object gets properly destructed.  An easy way to test this is to
return a C++ class with a private destructor: semantic analysis should
flag an error here with the attempt to call the destructor.</li>
<li>Inspect the generated AST by printing it using <code class="docutils literal"><span class="pre">clang</span> <span class="pre">-cc1</span> <span class="pre">-ast-print</span></code>,
to make sure you&#8217;re capturing all of the important information about how
the AST was written.</li>
<li>Inspect the generated AST under <code class="docutils literal"><span class="pre">clang</span> <span class="pre">-cc1</span> <span class="pre">-ast-dump</span></code> to verify that
all of the types in the generated AST line up the way you want them.
Remember that clients of the AST should never have to &#8220;think&#8221; to
understand what&#8217;s going on.  For example, all implicit conversions should
show up explicitly in the AST.</li>
<li>Write tests that use your expression as a subexpression of other,
well-known expressions.  Can you call a function using your expression as
an argument?  Can you use the ternary operator?</li>
</ul>
</li>
<li>Teach code generation to create IR to your AST node.  This step is the first
(and only) that requires knowledge of LLVM IR.  There are several things to
keep in mind:<ul>
<li>Code generation is separated into scalar/aggregate/complex and
lvalue/rvalue paths, depending on what kind of result your expression
produces.  On occasion, this requires some careful factoring of code to
avoid duplication.</li>
<li><code class="docutils literal"><span class="pre">CodeGenFunction</span></code> contains functions <code class="docutils literal"><span class="pre">ConvertType</span></code> and
<code class="docutils literal"><span class="pre">ConvertTypeForMem</span></code> that convert Clang&#8217;s types (<code class="docutils literal"><span class="pre">clang::Type*</span></code> or
<code class="docutils literal"><span class="pre">clang::QualType</span></code>) to LLVM types.  Use the former for values, and the
later for memory locations: test with the C++ &#8220;<code class="docutils literal"><span class="pre">bool</span></code>&#8221; type to check
this.  If you find that you are having to use LLVM bitcasts to make the
subexpressions of your expression have the type that your expression
expects, STOP!  Go fix semantic analysis and the AST so that you don&#8217;t
need these bitcasts.</li>
<li>The <code class="docutils literal"><span class="pre">CodeGenFunction</span></code> class has a number of helper functions to make
certain operations easy, such as generating code to produce an lvalue or
an rvalue, or to initialize a memory location with a given value.  Prefer
to use these functions rather than directly writing loads and stores,
because these functions take care of some of the tricky details for you
(e.g., for exceptions).</li>
<li>If your expression requires some special behavior in the event of an
exception, look at the <code class="docutils literal"><span class="pre">push*Cleanup</span></code> functions in <code class="docutils literal"><span class="pre">CodeGenFunction</span></code>
to introduce a cleanup.  You shouldn&#8217;t have to deal with
exception-handling directly.</li>
<li>Testing is extremely important in IR generation.  Use <code class="docutils literal"><span class="pre">clang</span> <span class="pre">-cc1</span>
<span class="pre">-emit-llvm</span></code> and <a class="reference external" href="http://llvm.org/docs/CommandGuide/FileCheck.html">FileCheck</a> to verify that you&#8217;re
generating the right IR.</li>
</ul>
</li>
<li>Teach template instantiation how to cope with your AST node, which requires
some fairly simple code:<ul>
<li>Make sure that your expression&#8217;s constructor properly computes the flags
for type dependence (i.e., the type your expression produces can change
from one instantiation to the next), value dependence (i.e., the constant
value your expression produces can change from one instantiation to the
next), instantiation dependence (i.e., a template parameter occurs
anywhere in your expression), and whether your expression contains a
parameter pack (for variadic templates).  Often, computing these flags
just means combining the results from the various types and
subexpressions.</li>
<li>Add <code class="docutils literal"><span class="pre">TransformXXX</span></code> and <code class="docutils literal"><span class="pre">RebuildXXX</span></code> functions to the <code class="docutils literal"><span class="pre">TreeTransform</span></code>
class template in <code class="docutils literal"><span class="pre">Sema</span></code>.  <code class="docutils literal"><span class="pre">TransformXXX</span></code> should (recursively)
transform all of the subexpressions and types within your expression,
using <code class="docutils literal"><span class="pre">getDerived().TransformYYY</span></code>.  If all of the subexpressions and
types transform without error, it will then call the <code class="docutils literal"><span class="pre">RebuildXXX</span></code>
function, which will in turn call <code class="docutils literal"><span class="pre">getSema().BuildXXX</span></code> to perform
semantic analysis and build your expression.</li>
<li>To test template instantiation, take those tests you wrote to make sure
that you were type checking with type-dependent expressions and dependent
types (from step #2) and instantiate those templates with various types,
some of which type-check and some that don&#8217;t, and test the error messages
in each case.</li>
</ul>
</li>
<li>There are some &#8220;extras&#8221; that make other features work better.  It&#8217;s worth
handling these extras to give your expression complete integration into
Clang:<ul>
<li>Add code completion support for your expression in
<code class="docutils literal"><span class="pre">SemaCodeComplete.cpp</span></code>.</li>
<li>If your expression has types in it, or has any &#8220;interesting&#8221; features
other than subexpressions, extend libclang&#8217;s <code class="docutils literal"><span class="pre">CursorVisitor</span></code> to provide
proper visitation for your expression, enabling various IDE features such
as syntax highlighting, cross-referencing, and so on.  The
<code class="docutils literal"><span class="pre">c-index-test</span></code> helper program can be used to test these features.</li>
</ul>
</li>
</ol>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ClangFormatStyleOptions.html">Clang-Format Style Options</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="DriverInternals.html">Driver Design &amp; Internals</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2007-2015, The Clang Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>