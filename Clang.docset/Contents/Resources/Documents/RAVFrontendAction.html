<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>How to write RecursiveASTVisitor based ASTFrontendActions. &mdash; Clang 4 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Clang 4 documentation" href="index.html" />
    <link rel="next" title="Tutorial for building tools using LibTooling and LibASTMatchers" href="LibASTMatchersTutorial.html" />
    <link rel="prev" title="Clang Plugins" href="ClangPlugins.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 4 documentation</span></a></h1>
        <h2 class="heading"><span>How to write RecursiveASTVisitor based ASTFrontendActions.</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ClangPlugins.html">Clang Plugins</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="LibASTMatchersTutorial.html">Tutorial for building tools using LibTooling and LibASTMatchers</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="how-to-write-recursiveastvisitor-based-astfrontendactions">
<h1>How to write RecursiveASTVisitor based ASTFrontendActions.<a class="headerlink" href="#how-to-write-recursiveastvisitor-based-astfrontendactions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In this tutorial you will learn how to create a FrontendAction that uses
a RecursiveASTVisitor to find CXXRecordDecl AST nodes with a specified
name.</p>
</div>
<div class="section" id="creating-a-frontendaction">
<h2>Creating a FrontendAction<a class="headerlink" href="#creating-a-frontendaction" title="Permalink to this headline">¶</a></h2>
<p>When writing a clang based tool like a Clang Plugin or a standalone tool
based on LibTooling, the common entry point is the FrontendAction.
FrontendAction is an interface that allows execution of user specific
actions as part of the compilation. To run tools over the AST clang
provides the convenience interface ASTFrontendAction, which takes care
of executing the action. The only part left is to implement the
CreateASTConsumer method that returns an ASTConsumer per translation
unit.</p>
<div class="highlight-python"><div class="highlight"><pre>class FindNamedClassAction : public clang::ASTFrontendAction {
public:
  virtual std::unique_ptr&lt;clang::ASTConsumer&gt; CreateASTConsumer(
    clang::CompilerInstance &amp;Compiler, llvm::StringRef InFile) {
    return std::unique_ptr&lt;clang::ASTConsumer&gt;(
        new FindNamedClassConsumer);
  }
};
</pre></div>
</div>
</div>
<div class="section" id="creating-an-astconsumer">
<h2>Creating an ASTConsumer<a class="headerlink" href="#creating-an-astconsumer" title="Permalink to this headline">¶</a></h2>
<p>ASTConsumer is an interface used to write generic actions on an AST,
regardless of how the AST was produced. ASTConsumer provides many
different entry points, but for our use case the only one needed is
HandleTranslationUnit, which is called with the ASTContext for the
translation unit.</p>
<div class="highlight-python"><div class="highlight"><pre>class FindNamedClassConsumer : public clang::ASTConsumer {
public:
  virtual void HandleTranslationUnit(clang::ASTContext &amp;Context) {
    // Traversing the translation unit decl via a RecursiveASTVisitor
    // will visit all nodes in the AST.
    Visitor.TraverseDecl(Context.getTranslationUnitDecl());
  }
private:
  // A RecursiveASTVisitor implementation.
  FindNamedClassVisitor Visitor;
};
</pre></div>
</div>
</div>
<div class="section" id="using-the-recursiveastvisitor">
<h2>Using the RecursiveASTVisitor<a class="headerlink" href="#using-the-recursiveastvisitor" title="Permalink to this headline">¶</a></h2>
<p>Now that everything is hooked up, the next step is to implement a
RecursiveASTVisitor to extract the relevant information from the AST.</p>
<p>The RecursiveASTVisitor provides hooks of the form bool
VisitNodeType(NodeType *) for most AST nodes; the exception are TypeLoc
nodes, which are passed by-value. We only need to implement the methods
for the relevant node types.</p>
<p>Let&#8217;s start by writing a RecursiveASTVisitor that visits all
CXXRecordDecl&#8217;s.</p>
<div class="highlight-python"><div class="highlight"><pre>class FindNamedClassVisitor
  : public RecursiveASTVisitor&lt;FindNamedClassVisitor&gt; {
public:
  bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
    // For debugging, dumping the AST nodes will show which nodes are already
    // being visited.
    Declaration-&gt;dump();

    // The return value indicates whether we want the visitation to proceed.
    // Return false to stop the traversal of the AST.
    return true;
  }
};
</pre></div>
</div>
<p>In the methods of our RecursiveASTVisitor we can now use the full power
of the Clang AST to drill through to the parts that are interesting for
us. For example, to find all class declaration with a certain name, we
can check for a specific qualified name:</p>
<div class="highlight-python"><div class="highlight"><pre>bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
  if (Declaration-&gt;getQualifiedNameAsString() == &quot;n::m::C&quot;)
    Declaration-&gt;dump();
  return true;
}
</pre></div>
</div>
</div>
<div class="section" id="accessing-the-sourcemanager-and-astcontext">
<h2>Accessing the SourceManager and ASTContext<a class="headerlink" href="#accessing-the-sourcemanager-and-astcontext" title="Permalink to this headline">¶</a></h2>
<p>Some of the information about the AST, like source locations and global
identifier information, are not stored in the AST nodes themselves, but
in the ASTContext and its associated source manager. To retrieve them we
need to hand the ASTContext into our RecursiveASTVisitor implementation.</p>
<p>The ASTContext is available from the CompilerInstance during the call to
CreateASTConsumer. We can thus extract it there and hand it into our
freshly created FindNamedClassConsumer:</p>
<div class="highlight-python"><div class="highlight"><pre>virtual std::unique_ptr&lt;clang::ASTConsumer&gt; CreateASTConsumer(
  clang::CompilerInstance &amp;Compiler, llvm::StringRef InFile) {
  return std::unique_ptr&lt;clang::ASTConsumer&gt;(
      new FindNamedClassConsumer(&amp;Compiler.getASTContext()));
}
</pre></div>
</div>
<p>Now that the ASTContext is available in the RecursiveASTVisitor, we can
do more interesting things with AST nodes, like looking up their source
locations:</p>
<div class="highlight-python"><div class="highlight"><pre>bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
  if (Declaration-&gt;getQualifiedNameAsString() == &quot;n::m::C&quot;) {
    // getFullLoc uses the ASTContext&#39;s SourceManager to resolve the source
    // location and break it up into its line and column parts.
    FullSourceLoc FullLocation = Context-&gt;getFullLoc(Declaration-&gt;getLocStart());
    if (FullLocation.isValid())
      llvm::outs() &lt;&lt; &quot;Found declaration at &quot;
                   &lt;&lt; FullLocation.getSpellingLineNumber() &lt;&lt; &quot;:&quot;
                   &lt;&lt; FullLocation.getSpellingColumnNumber() &lt;&lt; &quot;\n&quot;;
  }
  return true;
}
</pre></div>
</div>
</div>
<div class="section" id="putting-it-all-together">
<h2>Putting it all together<a class="headerlink" href="#putting-it-all-together" title="Permalink to this headline">¶</a></h2>
<p>Now we can combine all of the above into a small example program:</p>
<div class="highlight-python"><div class="highlight"><pre>#include &quot;clang/AST/ASTConsumer.h&quot;
#include &quot;clang/AST/RecursiveASTVisitor.h&quot;
#include &quot;clang/Frontend/CompilerInstance.h&quot;
#include &quot;clang/Frontend/FrontendAction.h&quot;
#include &quot;clang/Tooling/Tooling.h&quot;

using namespace clang;

class FindNamedClassVisitor
  : public RecursiveASTVisitor&lt;FindNamedClassVisitor&gt; {
public:
  explicit FindNamedClassVisitor(ASTContext *Context)
    : Context(Context) {}

  bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
    if (Declaration-&gt;getQualifiedNameAsString() == &quot;n::m::C&quot;) {
      FullSourceLoc FullLocation = Context-&gt;getFullLoc(Declaration-&gt;getLocStart());
      if (FullLocation.isValid())
        llvm::outs() &lt;&lt; &quot;Found declaration at &quot;
                     &lt;&lt; FullLocation.getSpellingLineNumber() &lt;&lt; &quot;:&quot;
                     &lt;&lt; FullLocation.getSpellingColumnNumber() &lt;&lt; &quot;\n&quot;;
    }
    return true;
  }

private:
  ASTContext *Context;
};

class FindNamedClassConsumer : public clang::ASTConsumer {
public:
  explicit FindNamedClassConsumer(ASTContext *Context)
    : Visitor(Context) {}

  virtual void HandleTranslationUnit(clang::ASTContext &amp;Context) {
    Visitor.TraverseDecl(Context.getTranslationUnitDecl());
  }
private:
  FindNamedClassVisitor Visitor;
};

class FindNamedClassAction : public clang::ASTFrontendAction {
public:
  virtual std::unique_ptr&lt;clang::ASTConsumer&gt; CreateASTConsumer(
    clang::CompilerInstance &amp;Compiler, llvm::StringRef InFile) {
    return std::unique_ptr&lt;clang::ASTConsumer&gt;(
        new FindNamedClassConsumer(&amp;Compiler.getASTContext()));
  }
};

int main(int argc, char **argv) {
  if (argc &gt; 1) {
    clang::tooling::runToolOnCode(new FindNamedClassAction, argv[1]);
  }
}
</pre></div>
</div>
<p>We store this into a file called FindClassDecls.cpp and create the
following CMakeLists.txt to link it:</p>
<div class="highlight-python"><div class="highlight"><pre>add_clang_executable(find-class-decls FindClassDecls.cpp)

target_link_libraries(find-class-decls clangTooling)
</pre></div>
</div>
<p>When running this tool over a small code snippet it will output all
declarations of a class n::m::C it found:</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./bin/find-class-decls &quot;namespace n { namespace m { class C {}; } }&quot;
Found declaration at 1:29
</pre></div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ClangPlugins.html">Clang Plugins</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="LibASTMatchersTutorial.html">Tutorial for building tools using LibTooling and LibASTMatchers</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2007-2017, The Clang Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>