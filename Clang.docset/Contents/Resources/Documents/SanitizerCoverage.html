<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>SanitizerCoverage &mdash; Clang 3.7 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Clang 3.7 documentation" href="index.html" />
    <link rel="next" title="Sanitizer special case list" href="SanitizerSpecialCaseList.html" />
    <link rel="prev" title="LeakSanitizer" href="LeakSanitizer.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 3.7 documentation</span></a></h1>
        <h2 class="heading"><span>SanitizerCoverage</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="LeakSanitizer.html">LeakSanitizer</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="SanitizerSpecialCaseList.html">Sanitizer special case list</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="sanitizercoverage">
<h1>SanitizerCoverage<a class="headerlink" href="#sanitizercoverage" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id1">Introduction</a></li>
<li><a class="reference internal" href="#how-to-build-and-run" id="id2">How to build and run</a></li>
<li><a class="reference internal" href="#postprocessing" id="id3">Postprocessing</a></li>
<li><a class="reference internal" href="#how-good-is-the-coverage" id="id4">How good is the coverage?</a></li>
<li><a class="reference internal" href="#edge-coverage" id="id5">Edge coverage</a></li>
<li><a class="reference internal" href="#bitset" id="id6">Bitset</a></li>
<li><a class="reference internal" href="#caller-callee-coverage" id="id7">Caller-callee coverage</a></li>
<li><a class="reference internal" href="#coverage-counters" id="id8">Coverage counters</a></li>
<li><a class="reference internal" href="#output-directory" id="id9">Output directory</a></li>
<li><a class="reference internal" href="#sudden-death" id="id10">Sudden death</a></li>
<li><a class="reference internal" href="#in-process-fuzzing" id="id11">In-process fuzzing</a></li>
<li><a class="reference internal" href="#performance" id="id12">Performance</a></li>
<li><a class="reference internal" href="#why-another-coverage" id="id13">Why another coverage?</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id1">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Sanitizer tools have a very simple code coverage tool built in. It allows to
get function-level, basic-block-level, and edge-level coverage at a very low
cost.</p>
</div>
<div class="section" id="how-to-build-and-run">
<h2><a class="toc-backref" href="#id2">How to build and run</a><a class="headerlink" href="#how-to-build-and-run" title="Permalink to this headline">¶</a></h2>
<p>SanitizerCoverage can be used with <a class="reference internal" href="AddressSanitizer.html"><em>AddressSanitizer</em></a>,
<a class="reference internal" href="LeakSanitizer.html"><em>LeakSanitizer</em></a>, <a class="reference internal" href="MemorySanitizer.html"><em>MemorySanitizer</em></a>, and UndefinedBehaviorSanitizer.
In addition to <code class="docutils literal"><span class="pre">-fsanitize=</span></code>, pass one of the following compile-time flags:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">-fsanitize-coverage=func</span></code> for function-level coverage (very fast).</li>
<li><code class="docutils literal"><span class="pre">-fsanitize-coverage=bb</span></code> for basic-block-level coverage (may add up to 30%
<strong>extra</strong> slowdown).</li>
<li><code class="docutils literal"><span class="pre">-fsanitize-coverage=edge</span></code> for edge-level coverage (up to 40% slowdown).</li>
</ul>
<p>You may also specify <code class="docutils literal"><span class="pre">-fsanitize-coverage=indirect-calls</span></code> for
additional <a class="reference internal" href="#caller-callee-coverage">caller-callee coverage</a>.</p>
<p>At run time, pass <code class="docutils literal"><span class="pre">coverage=1</span></code> in <code class="docutils literal"><span class="pre">ASAN_OPTIONS</span></code>, <code class="docutils literal"><span class="pre">LSAN_OPTIONS</span></code>,
<code class="docutils literal"><span class="pre">MSAN_OPTIONS</span></code> or <code class="docutils literal"><span class="pre">UBSAN_OPTIONS</span></code>, as appropriate.</p>
<p>To get <a class="reference internal" href="#coverage-counters">Coverage counters</a>, add <code class="docutils literal"><span class="pre">-fsanitize-coverage=8bit-counters</span></code>
to one of the above compile-time flags. At runtime, use
<code class="docutils literal"><span class="pre">*SAN_OPTIONS=coverage=1:coverage_counters=1</span></code>.</p>
<p>Example:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">%</span> cat -n cov.cc
<span class="go">     1  #include &lt;stdio.h&gt;</span>
<span class="go">     2  __attribute__((noinline))</span>
<span class="go">     3  void foo() { printf(&quot;foo\n&quot;); }</span>
<span class="go">     4</span>
<span class="go">     5  int main(int argc, char **argv) {</span>
<span class="go">     6    if (argc == 2)</span>
<span class="go">     7      foo();</span>
<span class="go">     8    printf(&quot;main\n&quot;);</span>
<span class="go">     9  }</span>
<span class="gp">%</span> clang++ -g cov.cc -fsanitize<span class="o">=</span>address -fsanitize-coverage<span class="o">=</span>func
<span class="gp">%</span> <span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">coverage</span><span class="o">=</span><span class="m">1</span> ./a.out<span class="p">;</span> ls -l *sancov
<span class="go">main</span>
<span class="go">-rw-r----- 1 kcc eng 4 Nov 27 12:21 a.out.22673.sancov</span>
<span class="gp">%</span> <span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">coverage</span><span class="o">=</span><span class="m">1</span> ./a.out foo <span class="p">;</span> ls -l *sancov
<span class="go">foo</span>
<span class="go">main</span>
<span class="go">-rw-r----- 1 kcc eng 4 Nov 27 12:21 a.out.22673.sancov</span>
<span class="go">-rw-r----- 1 kcc eng 8 Nov 27 12:21 a.out.22679.sancov</span>
</pre></div>
</div>
<p>Every time you run an executable instrumented with SanitizerCoverage
one <code class="docutils literal"><span class="pre">*.sancov</span></code> file is created during the process shutdown.
If the executable is dynamically linked against instrumented DSOs,
one <code class="docutils literal"><span class="pre">*.sancov</span></code> file will be also created for every DSO.</p>
</div>
<div class="section" id="postprocessing">
<h2><a class="toc-backref" href="#id3">Postprocessing</a><a class="headerlink" href="#postprocessing" title="Permalink to this headline">¶</a></h2>
<p>The format of <code class="docutils literal"><span class="pre">*.sancov</span></code> files is very simple: the first 8 bytes is the magic,
one of <code class="docutils literal"><span class="pre">0xC0BFFFFFFFFFFF64</span></code> and <code class="docutils literal"><span class="pre">0xC0BFFFFFFFFFFF32</span></code>. The last byte of the
magic defines the size of the following offsets. The rest of the data is the
offsets in the corresponding binary/DSO that were executed during the run.</p>
<p>A simple script
<code class="docutils literal"><span class="pre">$LLVM/projects/compiler-rt/lib/sanitizer_common/scripts/sancov.py</span></code> is
provided to dump these offsets.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">%</span> sancov.py print a.out.22679.sancov a.out.22673.sancov
<span class="go">sancov.py: read 2 PCs from a.out.22679.sancov</span>
<span class="go">sancov.py: read 1 PCs from a.out.22673.sancov</span>
<span class="go">sancov.py: 2 files merged; 2 PCs total</span>
<span class="go">0x465250</span>
<span class="go">0x4652a0</span>
</pre></div>
</div>
<p>You can then filter the output of <code class="docutils literal"><span class="pre">sancov.py</span></code> through <code class="docutils literal"><span class="pre">addr2line</span> <span class="pre">--exe</span>
<span class="pre">ObjectFile</span></code> or <code class="docutils literal"><span class="pre">llvm-symbolizer</span> <span class="pre">--obj</span> <span class="pre">ObjectFile</span></code> to get file names and line
numbers:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">%</span> sancov.py print a.out.22679.sancov a.out.22673.sancov 2&gt; /dev/null <span class="p">|</span> llvm-symbolizer --obj a.out
<span class="go">cov.cc:3</span>
<span class="go">cov.cc:5</span>
</pre></div>
</div>
</div>
<div class="section" id="how-good-is-the-coverage">
<h2><a class="toc-backref" href="#id4">How good is the coverage?</a><a class="headerlink" href="#how-good-is-the-coverage" title="Permalink to this headline">¶</a></h2>
<p>It is possible to find out which PCs are not covered, by subtracting the covered
set from the set of all instrumented PCs. The latter can be obtained by listing
all callsites of <code class="docutils literal"><span class="pre">__sanitizer_cov()</span></code> in the binary. On Linux, <code class="docutils literal"><span class="pre">sancov.py</span></code>
can do this for you. Just supply the path to binary and a list of covered PCs:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">%</span> sancov.py print a.out.12345.sancov &gt; covered.txt
<span class="go">sancov.py: read 2 64-bit PCs from a.out.12345.sancov</span>
<span class="go">sancov.py: 1 file merged; 2 PCs total</span>
<span class="gp">%</span> sancov.py missing a.out &lt; covered.txt
<span class="go">sancov.py: found 3 instrumented PCs in a.out</span>
<span class="go">sancov.py: read 2 PCs from stdin</span>
<span class="go">sancov.py: 1 PCs missing from coverage</span>
<span class="go">0x4cc61c</span>
</pre></div>
</div>
</div>
<div class="section" id="edge-coverage">
<h2><a class="toc-backref" href="#id5">Edge coverage</a><a class="headerlink" href="#edge-coverage" title="Permalink to this headline">¶</a></h2>
<p>Consider this code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It contains 3 basic blocks, let&#8217;s name them A, B, C:</p>
<div class="highlight-none"><div class="highlight"><pre>A
|\
| \
|  B
| /
|/
C
</pre></div>
</div>
<p>If blocks A, B, and C are all covered we know for certain that the edges A=&gt;B
and B=&gt;C were executed, but we still don&#8217;t know if the edge A=&gt;C was executed.
Such edges of control flow graph are called
<a class="reference external" href="http://en.wikipedia.org/wiki/Control_flow_graph#Special_edges">critical</a>. The
edge-level coverage (<code class="docutils literal"><span class="pre">-fsanitize-coverage=edge</span></code>) simply splits all critical
edges by introducing new dummy blocks and then instruments those blocks:</p>
<div class="highlight-none"><div class="highlight"><pre>A
|\
| \
D  B
| /
|/
C
</pre></div>
</div>
</div>
<div class="section" id="bitset">
<h2><a class="toc-backref" href="#id6">Bitset</a><a class="headerlink" href="#bitset" title="Permalink to this headline">¶</a></h2>
<p>When <code class="docutils literal"><span class="pre">coverage_bitset=1</span></code> run-time flag is given, the coverage will also be
dumped as a bitset (text file with 1 for blocks that have been executed and 0
for blocks that were not).</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">%</span> clang++ -fsanitize<span class="o">=</span>address -fsanitize-coverage<span class="o">=</span>edge cov.cc
<span class="gp">%</span> <span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_bitset=1&quot;</span> ./a.out
<span class="go">main</span>
<span class="gp">%</span> <span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_bitset=1&quot;</span> ./a.out 1
<span class="go">foo</span>
<span class="go">main</span>
<span class="gp">%</span> head *bitset*
<span class="go">==&gt; a.out.38214.bitset-sancov &lt;==</span>
<span class="go">01101</span>
<span class="go">==&gt; a.out.6128.bitset-sancov &lt;==</span>
<span class="go">11011%</span>
</pre></div>
</div>
<p>For a given executable the length of the bitset is always the same (well,
unless dlopen/dlclose come into play), so the bitset coverage can be
easily used for bitset-based corpus distillation.</p>
</div>
<div class="section" id="caller-callee-coverage">
<h2><a class="toc-backref" href="#id7">Caller-callee coverage</a><a class="headerlink" href="#caller-callee-coverage" title="Permalink to this headline">¶</a></h2>
<p>(Experimental!)
Every indirect function call is instrumented with a run-time function call that
captures caller and callee.  At the shutdown time the process dumps a separate
file called <code class="docutils literal"><span class="pre">caller-callee.PID.sancov</span></code> which contains caller/callee pairs as
pairs of lines (odd lines are callers, even lines are callees)</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">a.out 0x4a2e0c</span>
<span class="go">a.out 0x4a6510</span>
<span class="go">a.out 0x4a2e0c</span>
<span class="go">a.out 0x4a87f0</span>
</pre></div>
</div>
<p>Current limitations:</p>
<ul class="simple">
<li>Only the first 14 callees for every caller are recorded, the rest are silently
ignored.</li>
<li>The output format is not very compact since caller and callee may reside in
different modules and we need to spell out the module names.</li>
<li>The routine that dumps the output is not optimized for speed</li>
<li>Only Linux x86_64 is tested so far.</li>
<li>Sandboxes are not supported.</li>
</ul>
</div>
<div class="section" id="coverage-counters">
<h2><a class="toc-backref" href="#id8">Coverage counters</a><a class="headerlink" href="#coverage-counters" title="Permalink to this headline">¶</a></h2>
<p>This experimental feature is inspired by
<a class="reference external" href="http://lcamtuf.coredump.cx/afl/technical_details.txt">AFL</a>&#8216;s coverage
instrumentation. With additional compile-time and run-time flags you can get
more sensitive coverage information.  In addition to boolean values assigned to
every basic block (edge) the instrumentation will collect imprecise counters.
On exit, every counter will be mapped to a 8-bit bitset representing counter
ranges: <code class="docutils literal"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4-7,</span> <span class="pre">8-15,</span> <span class="pre">16-31,</span> <span class="pre">32-127,</span> <span class="pre">128+</span></code> and those 8-bit bitsets will
be dumped to disk.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">%</span> clang++ -g cov.cc -fsanitize<span class="o">=</span>address -fsanitize-coverage<span class="o">=</span>edge,8bit-counters
<span class="gp">%</span> <span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_counters=1&quot;</span> ./a.out
<span class="gp">%</span> ls -l *counters-sancov
<span class="go">... a.out.17110.counters-sancov</span>
<span class="gp">%</span> xxd *counters-sancov
<span class="go">0000000: 0001 0100 01</span>
</pre></div>
</div>
<p>These counters may also be used for in-process coverage-guided fuzzers. See
<code class="docutils literal"><span class="pre">include/sanitizer/coverage_interface.h</span></code>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// The coverage instrumentation may optionally provide imprecise counters.</span>
<span class="c1">// Rather than exposing the counter values to the user we instead map</span>
<span class="c1">// the counters to a bitset.</span>
<span class="c1">// Every counter is associated with 8 bits in the bitset.</span>
<span class="c1">// We define 8 value ranges: 1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+</span>
<span class="c1">// The i-th bit is set to 1 if the counter value is in the i-th range.</span>
<span class="c1">// This counter-based coverage implementation is *not* thread-safe.</span>

<span class="c1">// Returns the number of registered coverage counters.</span>
<span class="kt">uintptr_t</span> <span class="nf">__sanitizer_get_number_of_counters</span><span class="p">();</span>
<span class="c1">// Updates the counter &#39;bitset&#39;, clears the counters and returns the number of</span>
<span class="c1">// new bits in &#39;bitset&#39;.</span>
<span class="c1">// If &#39;bitset&#39; is nullptr, only clears the counters.</span>
<span class="c1">// Otherwise &#39;bitset&#39; should be at least</span>
<span class="c1">// __sanitizer_get_number_of_counters bytes long and 8-aligned.</span>
<span class="kt">uintptr_t</span>
<span class="nf">__sanitizer_update_counter_bitset_and_clear_counters</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bitset</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="output-directory">
<h2><a class="toc-backref" href="#id9">Output directory</a><a class="headerlink" href="#output-directory" title="Permalink to this headline">¶</a></h2>
<p>By default, .sancov files are created in the current working directory.
This can be changed with <code class="docutils literal"><span class="pre">ASAN_OPTIONS=coverage_dir=/path</span></code>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">%</span> <span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_dir=/tmp/cov&quot;</span> ./a.out foo
<span class="gp">%</span> ls -l /tmp/cov/*sancov
<span class="go">-rw-r----- 1 kcc eng 4 Nov 27 12:21 a.out.22673.sancov</span>
<span class="go">-rw-r----- 1 kcc eng 8 Nov 27 12:21 a.out.22679.sancov</span>
</pre></div>
</div>
</div>
<div class="section" id="sudden-death">
<h2><a class="toc-backref" href="#id10">Sudden death</a><a class="headerlink" href="#sudden-death" title="Permalink to this headline">¶</a></h2>
<p>Normally, coverage data is collected in memory and saved to disk when the
program exits (with an <code class="docutils literal"><span class="pre">atexit()</span></code> handler), when a SIGSEGV is caught, or when
<code class="docutils literal"><span class="pre">__sanitizer_cov_dump()</span></code> is called.</p>
<p>If the program ends with a signal that ASan does not handle (or can not handle
at all, like SIGKILL), coverage data will be lost. This is a big problem on
Android, where SIGKILL is a normal way of evicting applications from memory.</p>
<p>With <code class="docutils literal"><span class="pre">ASAN_OPTIONS=coverage=1:coverage_direct=1</span></code> coverage data is written to a
memory-mapped file as soon as it collected.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">%</span> <span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_direct=1&quot;</span> ./a.out
<span class="go">main</span>
<span class="gp">%</span> ls
<span class="go">7036.sancov.map  7036.sancov.raw  a.out</span>
<span class="gp">%</span> sancov.py rawunpack 7036.sancov.raw
<span class="go">sancov.py: reading map 7036.sancov.map</span>
<span class="go">sancov.py: unpacking 7036.sancov.raw</span>
<span class="go">writing 1 PCs to a.out.7036.sancov</span>
<span class="gp">%</span> sancov.py print a.out.7036.sancov
<span class="go">sancov.py: read 1 PCs from a.out.7036.sancov</span>
<span class="go">sancov.py: 1 files merged; 1 PCs total</span>
<span class="go">0x4b2bae</span>
</pre></div>
</div>
<p>Note that on 64-bit platforms, this method writes 2x more data than the default,
because it stores full PC values instead of 32-bit offsets.</p>
</div>
<div class="section" id="in-process-fuzzing">
<h2><a class="toc-backref" href="#id11">In-process fuzzing</a><a class="headerlink" href="#in-process-fuzzing" title="Permalink to this headline">¶</a></h2>
<p>Coverage data could be useful for fuzzers and sometimes it is preferable to run
a fuzzer in the same process as the code being fuzzed (in-process fuzzer).</p>
<p>You can use <code class="docutils literal"><span class="pre">__sanitizer_get_total_unique_coverage()</span></code> from
<code class="docutils literal"><span class="pre">&lt;sanitizer/coverage_interface.h&gt;</span></code> which returns the number of currently
covered entities in the program. This will tell the fuzzer if the coverage has
increased after testing every new input.</p>
<p>If a fuzzer finds a bug in the ASan run, you will need to save the reproducer
before exiting the process.  Use <code class="docutils literal"><span class="pre">__asan_set_death_callback</span></code> from
<code class="docutils literal"><span class="pre">&lt;sanitizer/asan_interface.h&gt;</span></code> to do that.</p>
<p>An example of such fuzzer can be found in <a class="reference external" href="http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Fuzzer/README.txt?view=markup">the LLVM tree</a>.</p>
</div>
<div class="section" id="performance">
<h2><a class="toc-backref" href="#id12">Performance</a><a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h2>
<p>This coverage implementation is <strong>fast</strong>. With function-level coverage
(<code class="docutils literal"><span class="pre">-fsanitize-coverage=func</span></code>) the overhead is not measurable. With
basic-block-level coverage (<code class="docutils literal"><span class="pre">-fsanitize-coverage=bb</span></code>) the overhead varies
between 0 and 25%.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">benchmark</th>
<th class="head">cov0</th>
<th class="head">cov1</th>
<th class="head">diff 0-1</th>
<th class="head">cov2</th>
<th class="head">diff 0-2</th>
<th class="head">diff 1-2</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>400.perlbench</td>
<td>1296.00</td>
<td>1307.00</td>
<td>1.01</td>
<td>1465.00</td>
<td>1.13</td>
<td>1.12</td>
</tr>
<tr class="row-odd"><td>401.bzip2</td>
<td>858.00</td>
<td>854.00</td>
<td>1.00</td>
<td>1010.00</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr class="row-even"><td>403.gcc</td>
<td>613.00</td>
<td>617.00</td>
<td>1.01</td>
<td>683.00</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr class="row-odd"><td>429.mcf</td>
<td>605.00</td>
<td>582.00</td>
<td>0.96</td>
<td>610.00</td>
<td>1.01</td>
<td>1.05</td>
</tr>
<tr class="row-even"><td>445.gobmk</td>
<td>896.00</td>
<td>880.00</td>
<td>0.98</td>
<td>1050.00</td>
<td>1.17</td>
<td>1.19</td>
</tr>
<tr class="row-odd"><td>456.hmmer</td>
<td>892.00</td>
<td>892.00</td>
<td>1.00</td>
<td>918.00</td>
<td>1.03</td>
<td>1.03</td>
</tr>
<tr class="row-even"><td>458.sjeng</td>
<td>995.00</td>
<td>1009.00</td>
<td>1.01</td>
<td>1217.00</td>
<td>1.22</td>
<td>1.21</td>
</tr>
<tr class="row-odd"><td>462.libquantum</td>
<td>497.00</td>
<td>492.00</td>
<td>0.99</td>
<td>534.00</td>
<td>1.07</td>
<td>1.09</td>
</tr>
<tr class="row-even"><td>464.h264ref</td>
<td>1461.00</td>
<td>1467.00</td>
<td>1.00</td>
<td>1543.00</td>
<td>1.06</td>
<td>1.05</td>
</tr>
<tr class="row-odd"><td>471.omnetpp</td>
<td>575.00</td>
<td>590.00</td>
<td>1.03</td>
<td>660.00</td>
<td>1.15</td>
<td>1.12</td>
</tr>
<tr class="row-even"><td>473.astar</td>
<td>658.00</td>
<td>652.00</td>
<td>0.99</td>
<td>715.00</td>
<td>1.09</td>
<td>1.10</td>
</tr>
<tr class="row-odd"><td>483.xalancbmk</td>
<td>471.00</td>
<td>491.00</td>
<td>1.04</td>
<td>582.00</td>
<td>1.24</td>
<td>1.19</td>
</tr>
<tr class="row-even"><td>433.milc</td>
<td>616.00</td>
<td>627.00</td>
<td>1.02</td>
<td>627.00</td>
<td>1.02</td>
<td>1.00</td>
</tr>
<tr class="row-odd"><td>444.namd</td>
<td>602.00</td>
<td>601.00</td>
<td>1.00</td>
<td>654.00</td>
<td>1.09</td>
<td>1.09</td>
</tr>
<tr class="row-even"><td>447.dealII</td>
<td>630.00</td>
<td>634.00</td>
<td>1.01</td>
<td>653.00</td>
<td>1.04</td>
<td>1.03</td>
</tr>
<tr class="row-odd"><td>450.soplex</td>
<td>365.00</td>
<td>368.00</td>
<td>1.01</td>
<td>395.00</td>
<td>1.08</td>
<td>1.07</td>
</tr>
<tr class="row-even"><td>453.povray</td>
<td>427.00</td>
<td>434.00</td>
<td>1.02</td>
<td>495.00</td>
<td>1.16</td>
<td>1.14</td>
</tr>
<tr class="row-odd"><td>470.lbm</td>
<td>357.00</td>
<td>375.00</td>
<td>1.05</td>
<td>370.00</td>
<td>1.04</td>
<td>0.99</td>
</tr>
<tr class="row-even"><td>482.sphinx3</td>
<td>927.00</td>
<td>928.00</td>
<td>1.00</td>
<td>1000.00</td>
<td>1.08</td>
<td>1.08</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="why-another-coverage">
<h2><a class="toc-backref" href="#id13">Why another coverage?</a><a class="headerlink" href="#why-another-coverage" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Why did we implement yet another code coverage?</dt>
<dd><ul class="first last simple">
<li>We needed something that is lightning fast, plays well with
AddressSanitizer, and does not significantly increase the binary size.</li>
<li>Traditional coverage implementations based in global counters
<a class="reference external" href="https://groups.google.com/forum/#!topic/llvm-dev/cDqYgnxNEhY">suffer from contention on counters</a>.</li>
</ul>
</dd>
</dl>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="LeakSanitizer.html">LeakSanitizer</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="SanitizerSpecialCaseList.html">Sanitizer special case list</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2007-2015, The Clang Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>